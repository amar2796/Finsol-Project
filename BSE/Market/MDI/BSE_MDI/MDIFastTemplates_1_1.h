// MDIFastTemplates_1_1.h generated by mFAST from FAST Template. 
// Do not modify this file directly. Any modifications 
// will be lost the next time this file is generated.

#pragma once

#include <mfast.h>
namespace MDIFastTemplates_1_1
{

class MDPacketHeader_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<MDPacketHeader_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    MDPacketHeader_cref();
    template <typename T>
    MDPacketHeader_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, MDPacketHeader_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    MDPacketHeader_cref(const mfast::message_cref& other);

    explicit MDPacketHeader_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_cref get_SenderCompID() const;
    mfast::uint32_cref try_get_SenderCompID() const;
    mfast::byte_vector_cref get_PacketSeqNum() const;
    mfast::byte_vector_cref try_get_PacketSeqNum() const;
    mfast::byte_vector_cref get_SendingTime() const;
    mfast::byte_vector_cref try_get_SendingTime() const;

};


typedef mfast::make_aggregate_mref<MDPacketHeader_cref> MDPacketHeader_mref_base;
class MDPacketHeader_mref
  : public MDPacketHeader_mref_base
{
  typedef MDPacketHeader_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<MDPacketHeader_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    MDPacketHeader_mref();
    template <typename T>
    MDPacketHeader_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, MDPacketHeader_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    MDPacketHeader_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit MDPacketHeader_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_SenderCompID() const;
    mfast::byte_vector_mref set_PacketSeqNum() const;
    mfast::byte_vector_mref set_SendingTime() const;
};

class MDPacketHeader
  : private mfast::value_storage_array<3>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 122
    };
    typedef mfast::template_instruction_ex<MDPacketHeader_cref> instruction_type;

    typedef mfast::make_message_cref<MDPacketHeader_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<MDPacketHeader_mref, instruction_type> mref_type;
    MDPacketHeader(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    MDPacketHeader(
      const MDPacketHeader_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit MDPacketHeader(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    MDPacketHeader(const MDPacketHeader&);
    MDPacketHeader& operator = (const MDPacketHeader&);
};


class ProductStateChange_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<ProductStateChange_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    ProductStateChange_cref();
    template <typename T>
    ProductStateChange_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, ProductStateChange_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    ProductStateChange_cref(const mfast::message_cref& other);

    explicit ProductStateChange_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MsgType() const;
    mfast::ascii_string_cref try_get_MsgType() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint32_cref get_SenderCompID() const;
    mfast::uint32_cref try_get_SenderCompID() const;
    mfast::uint32_cref get_MarketSegmentID() const;
    mfast::uint32_cref try_get_MarketSegmentID() const;
    mfast::uint32_cref get_TradingSessionID() const;
    mfast::uint32_cref try_get_TradingSessionID() const;
    mfast::uint32_cref get_TradingSessionSubID() const;
    mfast::uint32_cref try_get_TradingSessionSubID() const;
    mfast::uint32_cref get_TradSesStatus() const;
    mfast::uint32_cref try_get_TradSesStatus() const;
    mfast::uint32_cref get_FastMarketIndicator() const;
    mfast::uint32_cref try_get_FastMarketIndicator() const;
    mfast::int64_cref get_TransactTime() const;
    mfast::int64_cref try_get_TransactTime() const;

};


typedef mfast::make_aggregate_mref<ProductStateChange_cref> ProductStateChange_mref_base;
class ProductStateChange_mref
  : public ProductStateChange_mref_base
{
  typedef ProductStateChange_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<ProductStateChange_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    ProductStateChange_mref();
    template <typename T>
    ProductStateChange_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, ProductStateChange_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    ProductStateChange_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit ProductStateChange_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    mfast::uint32_mref set_SenderCompID() const;
    mfast::uint32_mref set_MarketSegmentID() const;
    mfast::uint32_mref set_TradingSessionID() const;
    mfast::uint32_mref set_TradingSessionSubID() const;
    mfast::uint32_mref set_TradSesStatus() const;
    mfast::uint32_mref set_FastMarketIndicator() const;
    mfast::int64_mref set_TransactTime() const;
};

class ProductStateChange
  : private mfast::value_storage_array<9>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 108
    };
    typedef mfast::template_instruction_ex<ProductStateChange_cref> instruction_type;

    typedef mfast::make_message_cref<ProductStateChange_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<ProductStateChange_mref, instruction_type> mref_type;
    ProductStateChange(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    ProductStateChange(
      const ProductStateChange_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit ProductStateChange(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    ProductStateChange(const ProductStateChange&);
    ProductStateChange& operator = (const ProductStateChange&);
};


class MassInstrumentStateChange_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<MassInstrumentStateChange_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    MassInstrumentStateChange_cref();
    template <typename T>
    MassInstrumentStateChange_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, MassInstrumentStateChange_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    MassInstrumentStateChange_cref(const mfast::message_cref& other);

    explicit MassInstrumentStateChange_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MsgType() const;
    mfast::ascii_string_cref try_get_MsgType() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint32_cref get_SenderCompID() const;
    mfast::uint32_cref try_get_SenderCompID() const;
    mfast::uint32_cref get_MarketSegmentID() const;
    mfast::uint32_cref try_get_MarketSegmentID() const;
    mfast::uint32_cref get_InstrumentScopeProductComplex() const;
    mfast::uint32_cref try_get_InstrumentScopeProductComplex() const;
    mfast::uint32_cref get_SecurityMassTradingStatus() const;
    mfast::uint32_cref try_get_SecurityMassTradingStatus() const;
    mfast::uint32_cref get_FastMarketIndicator() const;
    mfast::uint32_cref try_get_FastMarketIndicator() const;
    mfast::int64_cref get_TransactTime() const;
    mfast::int64_cref try_get_TransactTime() const;

    class SecMassStatGrp_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<SecMassStatGrp_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        SecMassStatGrp_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::int64_cref get_SecurityID() const;
        mfast::int64_cref try_get_SecurityID() const;
        mfast::ascii_string_cref get_SecurityIDSource() const;
        mfast::ascii_string_cref try_get_SecurityIDSource() const;
        mfast::uint32_cref get_SecurityStatus() const;
        mfast::uint32_cref try_get_SecurityStatus() const;
        mfast::uint32_cref get_SecurityTradingStatus() const;
        mfast::uint32_cref try_get_SecurityTradingStatus() const;
    };

    typedef mfast::make_sequence_cref<SecMassStatGrp_element_cref> SecMassStatGrp_cref;
    SecMassStatGrp_cref get_SecMassStatGrp() const;
    SecMassStatGrp_cref try_get_SecMassStatGrp() const;

};


typedef mfast::make_aggregate_mref<MassInstrumentStateChange_cref> MassInstrumentStateChange_mref_base;
class MassInstrumentStateChange_mref
  : public MassInstrumentStateChange_mref_base
{
  typedef MassInstrumentStateChange_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<MassInstrumentStateChange_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    MassInstrumentStateChange_mref();
    template <typename T>
    MassInstrumentStateChange_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, MassInstrumentStateChange_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    MassInstrumentStateChange_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit MassInstrumentStateChange_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    mfast::uint32_mref set_SenderCompID() const;
    mfast::uint32_mref set_MarketSegmentID() const;
    mfast::uint32_mref set_InstrumentScopeProductComplex() const;
    mfast::uint32_mref set_SecurityMassTradingStatus() const;
    mfast::uint32_mref set_FastMarketIndicator() const;
    mfast::int64_mref set_TransactTime() const;

    class SecMassStatGrp_element_mref
      : public mfast::make_aggregate_mref<MassInstrumentStateChange_cref::SecMassStatGrp_element_cref>
    {
      typedef mfast::make_aggregate_mref<MassInstrumentStateChange_cref::SecMassStatGrp_element_cref> base_type;
      public:
        SecMassStatGrp_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::int64_mref set_SecurityID() const;
        mfast::uint32_mref set_SecurityStatus() const;
        mfast::uint32_mref set_SecurityTradingStatus() const;
    };

    typedef mfast::make_sequence_mref<SecMassStatGrp_element_mref> SecMassStatGrp_mref;
    SecMassStatGrp_mref set_SecMassStatGrp() const;
};

class MassInstrumentStateChange
  : private mfast::value_storage_array<9>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 104
    };
    typedef mfast::template_instruction_ex<MassInstrumentStateChange_cref> instruction_type;

    typedef mfast::make_message_cref<MassInstrumentStateChange_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<MassInstrumentStateChange_mref, instruction_type> mref_type;
    MassInstrumentStateChange(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    MassInstrumentStateChange(
      const MassInstrumentStateChange_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit MassInstrumentStateChange(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    MassInstrumentStateChange(const MassInstrumentStateChange&);
    MassInstrumentStateChange& operator = (const MassInstrumentStateChange&);
};


class InstrumentStateChange_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<InstrumentStateChange_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    InstrumentStateChange_cref();
    template <typename T>
    InstrumentStateChange_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, InstrumentStateChange_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    InstrumentStateChange_cref(const mfast::message_cref& other);

    explicit InstrumentStateChange_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MsgType() const;
    mfast::ascii_string_cref try_get_MsgType() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint32_cref get_SenderCompID() const;
    mfast::uint32_cref try_get_SenderCompID() const;
    mfast::uint32_cref get_MarketSegmentID() const;
    mfast::uint32_cref try_get_MarketSegmentID() const;
    mfast::int64_cref get_SecurityID() const;
    mfast::int64_cref try_get_SecurityID() const;
    mfast::ascii_string_cref get_SecurityIDSource() const;
    mfast::ascii_string_cref try_get_SecurityIDSource() const;
    mfast::uint32_cref get_SecurityStatus() const;
    mfast::uint32_cref try_get_SecurityStatus() const;
    mfast::uint32_cref get_SecurityTradingStatus() const;
    mfast::uint32_cref try_get_SecurityTradingStatus() const;
    mfast::uint32_cref get_FastMarketIndicator() const;
    mfast::uint32_cref try_get_FastMarketIndicator() const;
    mfast::int64_cref get_TransactTime() const;
    mfast::int64_cref try_get_TransactTime() const;

};


typedef mfast::make_aggregate_mref<InstrumentStateChange_cref> InstrumentStateChange_mref_base;
class InstrumentStateChange_mref
  : public InstrumentStateChange_mref_base
{
  typedef InstrumentStateChange_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<InstrumentStateChange_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    InstrumentStateChange_mref();
    template <typename T>
    InstrumentStateChange_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, InstrumentStateChange_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    InstrumentStateChange_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit InstrumentStateChange_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    mfast::uint32_mref set_SenderCompID() const;
    mfast::uint32_mref set_MarketSegmentID() const;
    mfast::int64_mref set_SecurityID() const;
    mfast::uint32_mref set_SecurityStatus() const;
    mfast::uint32_mref set_SecurityTradingStatus() const;
    mfast::uint32_mref set_FastMarketIndicator() const;
    mfast::int64_mref set_TransactTime() const;
};

class InstrumentStateChange
  : private mfast::value_storage_array<10>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 103
    };
    typedef mfast::template_instruction_ex<InstrumentStateChange_cref> instruction_type;

    typedef mfast::make_message_cref<InstrumentStateChange_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<InstrumentStateChange_mref, instruction_type> mref_type;
    InstrumentStateChange(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    InstrumentStateChange(
      const InstrumentStateChange_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit InstrumentStateChange(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    InstrumentStateChange(const InstrumentStateChange&);
    InstrumentStateChange& operator = (const InstrumentStateChange&);
};


class DepthIncremental_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<DepthIncremental_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    DepthIncremental_cref();
    template <typename T>
    DepthIncremental_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, DepthIncremental_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    DepthIncremental_cref(const mfast::message_cref& other);

    explicit DepthIncremental_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MsgType() const;
    mfast::ascii_string_cref try_get_MsgType() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint32_cref get_SenderCompID() const;
    mfast::uint32_cref try_get_SenderCompID() const;
    mfast::uint32_cref get_MarketSegmentID() const;
    mfast::uint32_cref try_get_MarketSegmentID() const;

    class MDIncGrp_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<MDIncGrp_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        MDIncGrp_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_cref get_MDUpdateAction() const;
        mfast::uint32_cref try_get_MDUpdateAction() const;
        mfast::uint32_cref get_MDEntryType() const;
        mfast::uint32_cref try_get_MDEntryType() const;
        mfast::int64_cref get_SecurityID() const;
        mfast::int64_cref try_get_SecurityID() const;
        mfast::ascii_string_cref get_SecurityIDSource() const;
        mfast::ascii_string_cref try_get_SecurityIDSource() const;
        mfast::decimal_cref get_MDEntryPx() const;
        mfast::decimal_cref try_get_MDEntryPx() const;
        mfast::decimal_cref get_Yield() const;
        mfast::decimal_cref try_get_Yield() const;
        mfast::decimal_cref get_PutYield() const;
        mfast::decimal_cref try_get_PutYield() const;
        mfast::decimal_cref get_CallYield() const;
        mfast::decimal_cref try_get_CallYield() const;
        mfast::uint32_cref get_MDEntrySize() const;
        mfast::uint32_cref try_get_MDEntrySize() const;
        mfast::uint32_cref get_NumberOfOrders() const;
        mfast::uint32_cref try_get_NumberOfOrders() const;
        mfast::uint32_cref get_MDPriceLevel() const;
        mfast::uint32_cref try_get_MDPriceLevel() const;
        mfast::uint64_cref get_BidSize() const;
        mfast::uint64_cref try_get_BidSize() const;
        mfast::uint64_cref get_OfferSize() const;
        mfast::uint64_cref try_get_OfferSize() const;
        mfast::int64_cref get_MDEntryTime() const;
        mfast::int64_cref try_get_MDEntryTime() const;

        class TradeEntryGrp_cref
          : public mfast::aggregate_cref
        {
          typedef mfast::aggregate_cref base_type;
          public:
            typedef mfast::group_instruction_ex<TradeEntryGrp_cref> instruction_type;

            typedef const instruction_type* instruction_cptr;
            TradeEntryGrp_cref();
            template <typename T>
            TradeEntryGrp_cref(
              typename std::enable_if<std::is_same<typename T::cref_type, TradeEntryGrp_cref>::value, const mfast::value_storage*>::type storage,
              const T* instruction);

            explicit TradeEntryGrp_cref(const mfast::field_cref& other);

            template <typename Visitor>
            void accept(Visitor& v);

            mfast::uint32_cref get_TrdType() const;
            mfast::uint32_cref try_get_TrdType() const;
            mfast::uint64_cref get_TradeVolume() const;
            mfast::uint64_cref try_get_TradeVolume() const;
            mfast::uint64_cref get_TradeCondition() const;
            mfast::uint64_cref try_get_TradeCondition() const;
            mfast::uint32_cref get_MDGapIndicator() const;
            mfast::uint32_cref try_get_MDGapIndicator() const;
            mfast::int64_cref get_AggressorTimestamp() const;
            mfast::int64_cref try_get_AggressorTimestamp() const;
            mfast::uint32_cref get_AggressorSide() const;
            mfast::uint32_cref try_get_AggressorSide() const;
            mfast::uint32_cref get_NumberOfBuyOrders() const;
            mfast::uint32_cref try_get_NumberOfBuyOrders() const;
            mfast::uint32_cref get_NumberOfSellOrders() const;
            mfast::uint32_cref try_get_NumberOfSellOrders() const;
            mfast::uint32_cref get_MDEntryID() const;
            mfast::uint32_cref try_get_MDEntryID() const;
        };

        TradeEntryGrp_cref get_TradeEntryGrp() const;
        TradeEntryGrp_cref try_get_TradeEntryGrp() const;
    };

    typedef mfast::make_sequence_cref<MDIncGrp_element_cref> MDIncGrp_cref;
    MDIncGrp_cref get_MDIncGrp() const;
    MDIncGrp_cref try_get_MDIncGrp() const;

};


typedef mfast::make_aggregate_mref<DepthIncremental_cref> DepthIncremental_mref_base;
class DepthIncremental_mref
  : public DepthIncremental_mref_base
{
  typedef DepthIncremental_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<DepthIncremental_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    DepthIncremental_mref();
    template <typename T>
    DepthIncremental_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, DepthIncremental_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    DepthIncremental_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit DepthIncremental_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    mfast::uint32_mref set_SenderCompID() const;
    mfast::uint32_mref set_MarketSegmentID() const;

    class MDIncGrp_element_mref
      : public mfast::make_aggregate_mref<DepthIncremental_cref::MDIncGrp_element_cref>
    {
      typedef mfast::make_aggregate_mref<DepthIncremental_cref::MDIncGrp_element_cref> base_type;
      public:
        MDIncGrp_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_mref set_MDUpdateAction() const;
        mfast::uint32_mref set_MDEntryType() const;
        mfast::int64_mref set_SecurityID() const;
        mfast::decimal_mref set_MDEntryPx() const;
        void omit_MDEntryPx() const;
        mfast::decimal_mref set_Yield() const;
        void omit_Yield() const;
        mfast::decimal_mref set_PutYield() const;
        void omit_PutYield() const;
        mfast::decimal_mref set_CallYield() const;
        void omit_CallYield() const;
        mfast::uint32_mref set_MDEntrySize() const;
        void omit_MDEntrySize() const;
        mfast::uint32_mref set_NumberOfOrders() const;
        void omit_NumberOfOrders() const;
        mfast::uint32_mref set_MDPriceLevel() const;
        void omit_MDPriceLevel() const;
        mfast::uint64_mref set_BidSize() const;
        void omit_BidSize() const;
        mfast::uint64_mref set_OfferSize() const;
        void omit_OfferSize() const;
        mfast::int64_mref set_MDEntryTime() const;
        void omit_MDEntryTime() const;

        class TradeEntryGrp_mref
          : public mfast::make_aggregate_mref<DepthIncremental_cref::MDIncGrp_element_cref::TradeEntryGrp_cref>
        {
          typedef mfast::make_aggregate_mref<DepthIncremental_cref::MDIncGrp_element_cref::TradeEntryGrp_cref> base_type;
          public:
            TradeEntryGrp_mref();
            template <typename T>
            TradeEntryGrp_mref(
              mfast::allocator*       alloc,
              typename std::enable_if<std::is_same<typename T::cref_type, TradeEntryGrp_cref>::value, mfast::value_storage*>::type   storage,
              const T* instruction);

            explicit TradeEntryGrp_mref(const mfast::field_mref_base& other);

            template <typename Visitor>
            void accept(Visitor& v);

            mfast::uint32_mref set_TrdType() const;
            void omit_TrdType() const;
            mfast::uint64_mref set_TradeVolume() const;
            void omit_TradeVolume() const;
            mfast::uint64_mref set_TradeCondition() const;
            void omit_TradeCondition() const;
            void omit_MDGapIndicator() const;
            mfast::int64_mref set_AggressorTimestamp() const;
            void omit_AggressorTimestamp() const;
            mfast::uint32_mref set_AggressorSide() const;
            void omit_AggressorSide() const;
            mfast::uint32_mref set_NumberOfBuyOrders() const;
            void omit_NumberOfBuyOrders() const;
            mfast::uint32_mref set_NumberOfSellOrders() const;
            void omit_NumberOfSellOrders() const;
            mfast::uint32_mref set_MDEntryID() const;
            void omit_MDEntryID() const;
        };

        TradeEntryGrp_mref set_TradeEntryGrp() const;
        void omit_TradeEntryGrp() const;
    };

    typedef mfast::make_sequence_mref<MDIncGrp_element_mref> MDIncGrp_mref;
    MDIncGrp_mref set_MDIncGrp() const;
};

class DepthIncremental
  : private mfast::value_storage_array<5>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 102
    };
    typedef mfast::template_instruction_ex<DepthIncremental_cref> instruction_type;

    typedef mfast::make_message_cref<DepthIncremental_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<DepthIncremental_mref, instruction_type> mref_type;
    DepthIncremental(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    DepthIncremental(
      const DepthIncremental_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit DepthIncremental(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    DepthIncremental(const DepthIncremental&);
    DepthIncremental& operator = (const DepthIncremental&);
};


class ComplexInstrumentUpdate_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<ComplexInstrumentUpdate_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    ComplexInstrumentUpdate_cref();
    template <typename T>
    ComplexInstrumentUpdate_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, ComplexInstrumentUpdate_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    ComplexInstrumentUpdate_cref(const mfast::message_cref& other);

    explicit ComplexInstrumentUpdate_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MsgType() const;
    mfast::ascii_string_cref try_get_MsgType() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint32_cref get_SenderCompID() const;
    mfast::uint32_cref try_get_SenderCompID() const;
    mfast::ascii_string_cref get_SecurityUpdateAction() const;
    mfast::ascii_string_cref try_get_SecurityUpdateAction() const;
    mfast::int64_cref get_SecurityID() const;
    mfast::int64_cref try_get_SecurityID() const;
    mfast::ascii_string_cref get_SecurityIDSource() const;
    mfast::ascii_string_cref try_get_SecurityIDSource() const;
    mfast::ascii_string_cref get_SecurityDesc() const;
    mfast::ascii_string_cref try_get_SecurityDesc() const;
    mfast::uint32_cref get_SecurityType() const;
    mfast::uint32_cref try_get_SecurityType() const;
    mfast::uint32_cref get_SecuritySubType() const;
    mfast::uint32_cref try_get_SecuritySubType() const;
    mfast::uint32_cref get_ProductComplex() const;
    mfast::uint32_cref try_get_ProductComplex() const;

    class InstrmtLegGrp_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<InstrmtLegGrp_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        InstrmtLegGrp_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::int64_cref get_LegSecurityID() const;
        mfast::int64_cref try_get_LegSecurityID() const;
        mfast::ascii_string_cref get_LegSecurityIDSource() const;
        mfast::ascii_string_cref try_get_LegSecurityIDSource() const;
        mfast::uint32_cref get_LegRatioQty() const;
        mfast::uint32_cref try_get_LegRatioQty() const;
        mfast::uint32_cref get_LegSide() const;
        mfast::uint32_cref try_get_LegSide() const;
        mfast::decimal_cref get_LegPrice() const;
        mfast::decimal_cref try_get_LegPrice() const;
    };

    typedef mfast::make_sequence_cref<InstrmtLegGrp_element_cref> InstrmtLegGrp_cref;
    InstrmtLegGrp_cref get_InstrmtLegGrp() const;
    InstrmtLegGrp_cref try_get_InstrmtLegGrp() const;

    class MarketSegmentGrp_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<MarketSegmentGrp_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        MarketSegmentGrp_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_cref get_MarketSegmentID() const;
        mfast::uint32_cref try_get_MarketSegmentID() const;
        mfast::uint32_cref get_ImpliedMarketIndicator() const;
        mfast::uint32_cref try_get_ImpliedMarketIndicator() const;
    };

    typedef mfast::make_sequence_cref<MarketSegmentGrp_element_cref> MarketSegmentGrp_cref;
    MarketSegmentGrp_cref get_MarketSegmentGrp() const;
    MarketSegmentGrp_cref try_get_MarketSegmentGrp() const;
    mfast::int64_cref get_TransactTime() const;
    mfast::int64_cref try_get_TransactTime() const;

};


typedef mfast::make_aggregate_mref<ComplexInstrumentUpdate_cref> ComplexInstrumentUpdate_mref_base;
class ComplexInstrumentUpdate_mref
  : public ComplexInstrumentUpdate_mref_base
{
  typedef ComplexInstrumentUpdate_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<ComplexInstrumentUpdate_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    ComplexInstrumentUpdate_mref();
    template <typename T>
    ComplexInstrumentUpdate_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, ComplexInstrumentUpdate_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    ComplexInstrumentUpdate_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit ComplexInstrumentUpdate_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    mfast::uint32_mref set_SenderCompID() const;
    mfast::int64_mref set_SecurityID() const;
    mfast::ascii_string_mref set_SecurityDesc() const;
    mfast::uint32_mref set_SecuritySubType() const;
    void omit_SecuritySubType() const;
    mfast::uint32_mref set_ProductComplex() const;

    class InstrmtLegGrp_element_mref
      : public mfast::make_aggregate_mref<ComplexInstrumentUpdate_cref::InstrmtLegGrp_element_cref>
    {
      typedef mfast::make_aggregate_mref<ComplexInstrumentUpdate_cref::InstrmtLegGrp_element_cref> base_type;
      public:
        InstrmtLegGrp_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::int64_mref set_LegSecurityID() const;
        mfast::uint32_mref set_LegRatioQty() const;
        mfast::uint32_mref set_LegSide() const;
        mfast::decimal_mref set_LegPrice() const;
        void omit_LegPrice() const;
    };

    typedef mfast::make_sequence_mref<InstrmtLegGrp_element_mref> InstrmtLegGrp_mref;
    InstrmtLegGrp_mref set_InstrmtLegGrp() const;

    class MarketSegmentGrp_element_mref
      : public mfast::make_aggregate_mref<ComplexInstrumentUpdate_cref::MarketSegmentGrp_element_cref>
    {
      typedef mfast::make_aggregate_mref<ComplexInstrumentUpdate_cref::MarketSegmentGrp_element_cref> base_type;
      public:
        MarketSegmentGrp_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_mref set_MarketSegmentID() const;
        mfast::uint32_mref set_ImpliedMarketIndicator() const;
    };

    typedef mfast::make_sequence_mref<MarketSegmentGrp_element_mref> MarketSegmentGrp_mref;
    MarketSegmentGrp_mref set_MarketSegmentGrp() const;
    mfast::int64_mref set_TransactTime() const;
};

class ComplexInstrumentUpdate
  : private mfast::value_storage_array<13>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 105
    };
    typedef mfast::template_instruction_ex<ComplexInstrumentUpdate_cref> instruction_type;

    typedef mfast::make_message_cref<ComplexInstrumentUpdate_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<ComplexInstrumentUpdate_mref, instruction_type> mref_type;
    ComplexInstrumentUpdate(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    ComplexInstrumentUpdate(
      const ComplexInstrumentUpdate_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit ComplexInstrumentUpdate(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    ComplexInstrumentUpdate(const ComplexInstrumentUpdate&);
    ComplexInstrumentUpdate& operator = (const ComplexInstrumentUpdate&);
};


class QuoteRequest_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<QuoteRequest_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    QuoteRequest_cref();
    template <typename T>
    QuoteRequest_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, QuoteRequest_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    QuoteRequest_cref(const mfast::message_cref& other);

    explicit QuoteRequest_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MsgType() const;
    mfast::ascii_string_cref try_get_MsgType() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint32_cref get_SenderCompID() const;
    mfast::uint32_cref try_get_SenderCompID() const;
    mfast::uint32_cref get_MarketSegmentID() const;
    mfast::uint32_cref try_get_MarketSegmentID() const;

    class QuotReqGrp_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<QuotReqGrp_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        QuotReqGrp_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::int64_cref get_SecurityID() const;
        mfast::int64_cref try_get_SecurityID() const;
        mfast::ascii_string_cref get_SecurityIDSource() const;
        mfast::ascii_string_cref try_get_SecurityIDSource() const;
        mfast::uint32_cref get_Side() const;
        mfast::uint32_cref try_get_Side() const;
        mfast::uint32_cref get_OrderQty() const;
        mfast::uint32_cref try_get_OrderQty() const;
        mfast::int64_cref get_TransactTime() const;
        mfast::int64_cref try_get_TransactTime() const;
    };

    typedef mfast::make_sequence_cref<QuotReqGrp_element_cref> QuotReqGrp_cref;
    QuotReqGrp_cref get_QuotReqGrp() const;
    QuotReqGrp_cref try_get_QuotReqGrp() const;

};


typedef mfast::make_aggregate_mref<QuoteRequest_cref> QuoteRequest_mref_base;
class QuoteRequest_mref
  : public QuoteRequest_mref_base
{
  typedef QuoteRequest_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<QuoteRequest_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    QuoteRequest_mref();
    template <typename T>
    QuoteRequest_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, QuoteRequest_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    QuoteRequest_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit QuoteRequest_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    mfast::uint32_mref set_SenderCompID() const;
    mfast::uint32_mref set_MarketSegmentID() const;

    class QuotReqGrp_element_mref
      : public mfast::make_aggregate_mref<QuoteRequest_cref::QuotReqGrp_element_cref>
    {
      typedef mfast::make_aggregate_mref<QuoteRequest_cref::QuotReqGrp_element_cref> base_type;
      public:
        QuotReqGrp_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::int64_mref set_SecurityID() const;
        mfast::uint32_mref set_Side() const;
        void omit_Side() const;
        mfast::uint32_mref set_OrderQty() const;
        void omit_OrderQty() const;
        mfast::int64_mref set_TransactTime() const;
    };

    typedef mfast::make_sequence_mref<QuotReqGrp_element_mref> QuotReqGrp_mref;
    QuotReqGrp_mref set_QuotReqGrp() const;
};

class QuoteRequest
  : private mfast::value_storage_array<5>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 106
    };
    typedef mfast::template_instruction_ex<QuoteRequest_cref> instruction_type;

    typedef mfast::make_message_cref<QuoteRequest_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<QuoteRequest_mref, instruction_type> mref_type;
    QuoteRequest(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    QuoteRequest(
      const QuoteRequest_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit QuoteRequest(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    QuoteRequest(const QuoteRequest&);
    QuoteRequest& operator = (const QuoteRequest&);
};


class CrossRequest_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<CrossRequest_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    CrossRequest_cref();
    template <typename T>
    CrossRequest_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, CrossRequest_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    CrossRequest_cref(const mfast::message_cref& other);

    explicit CrossRequest_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MsgType() const;
    mfast::ascii_string_cref try_get_MsgType() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint32_cref get_SenderCompID() const;
    mfast::uint32_cref try_get_SenderCompID() const;
    mfast::uint32_cref get_MarketSegmentID() const;
    mfast::uint32_cref try_get_MarketSegmentID() const;
    mfast::int64_cref get_SecurityID() const;
    mfast::int64_cref try_get_SecurityID() const;
    mfast::ascii_string_cref get_SecurityIDSource() const;
    mfast::ascii_string_cref try_get_SecurityIDSource() const;
    mfast::uint32_cref get_OrderQty() const;
    mfast::uint32_cref try_get_OrderQty() const;
    mfast::int64_cref get_TransactTime() const;
    mfast::int64_cref try_get_TransactTime() const;

};


typedef mfast::make_aggregate_mref<CrossRequest_cref> CrossRequest_mref_base;
class CrossRequest_mref
  : public CrossRequest_mref_base
{
  typedef CrossRequest_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<CrossRequest_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    CrossRequest_mref();
    template <typename T>
    CrossRequest_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, CrossRequest_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    CrossRequest_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit CrossRequest_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    mfast::uint32_mref set_SenderCompID() const;
    mfast::uint32_mref set_MarketSegmentID() const;
    mfast::int64_mref set_SecurityID() const;
    mfast::uint32_mref set_OrderQty() const;
    mfast::int64_mref set_TransactTime() const;
};

class CrossRequest
  : private mfast::value_storage_array<8>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 107
    };
    typedef mfast::template_instruction_ex<CrossRequest_cref> instruction_type;

    typedef mfast::make_message_cref<CrossRequest_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<CrossRequest_mref, instruction_type> mref_type;
    CrossRequest(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    CrossRequest(
      const CrossRequest_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit CrossRequest(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    CrossRequest(const CrossRequest&);
    CrossRequest& operator = (const CrossRequest&);
};


class DepthSnapshot_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<DepthSnapshot_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    DepthSnapshot_cref();
    template <typename T>
    DepthSnapshot_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, DepthSnapshot_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    DepthSnapshot_cref(const mfast::message_cref& other);

    explicit DepthSnapshot_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MsgType() const;
    mfast::ascii_string_cref try_get_MsgType() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint32_cref get_SenderCompID() const;
    mfast::uint32_cref try_get_SenderCompID() const;
    mfast::uint32_cref get_LastMsgSeqNumProcessed() const;
    mfast::uint32_cref try_get_LastMsgSeqNumProcessed() const;
    mfast::uint32_cref get_RefreshIndicator() const;
    mfast::uint32_cref try_get_RefreshIndicator() const;
    mfast::uint32_cref get_MarketSegmentID() const;
    mfast::uint32_cref try_get_MarketSegmentID() const;
    mfast::int64_cref get_SecurityID() const;
    mfast::int64_cref try_get_SecurityID() const;
    mfast::ascii_string_cref get_SecurityIDSource() const;
    mfast::ascii_string_cref try_get_SecurityIDSource() const;
    mfast::uint32_cref get_ProductComplex() const;
    mfast::uint32_cref try_get_ProductComplex() const;
    mfast::uint32_cref get_SecurityStatus() const;
    mfast::uint32_cref try_get_SecurityStatus() const;
    mfast::uint64_cref get_BidSize() const;
    mfast::uint64_cref try_get_BidSize() const;
    mfast::uint64_cref get_OfferSize() const;
    mfast::uint64_cref try_get_OfferSize() const;
    mfast::int64_cref get_LastUpdateTime() const;
    mfast::int64_cref try_get_LastUpdateTime() const;

    class MDSshGrp_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<MDSshGrp_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        MDSshGrp_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_cref get_MDEntryType() const;
        mfast::uint32_cref try_get_MDEntryType() const;
        mfast::uint32_cref get_TrdType() const;
        mfast::uint32_cref try_get_TrdType() const;
        mfast::uint32_cref get_TradingSessionID() const;
        mfast::uint32_cref try_get_TradingSessionID() const;
        mfast::uint32_cref get_TradingSessionSubID() const;
        mfast::uint32_cref try_get_TradingSessionSubID() const;
        mfast::uint32_cref get_FastMarketIndicator() const;
        mfast::uint32_cref try_get_FastMarketIndicator() const;
        mfast::uint32_cref get_SecurityTradingStatus() const;
        mfast::uint32_cref try_get_SecurityTradingStatus() const;
        mfast::uint64_cref get_TradeCondition() const;
        mfast::uint64_cref try_get_TradeCondition() const;
        mfast::decimal_cref get_MDEntryPx() const;
        mfast::decimal_cref try_get_MDEntryPx() const;
        mfast::decimal_cref get_Yield() const;
        mfast::decimal_cref try_get_Yield() const;
        mfast::decimal_cref get_PutYield() const;
        mfast::decimal_cref try_get_PutYield() const;
        mfast::decimal_cref get_CallYield() const;
        mfast::decimal_cref try_get_CallYield() const;
        mfast::uint32_cref get_MDEntrySize() const;
        mfast::uint32_cref try_get_MDEntrySize() const;
        mfast::uint32_cref get_NumberOfOrders() const;
        mfast::uint32_cref try_get_NumberOfOrders() const;
        mfast::uint32_cref get_MDPriceLevel() const;
        mfast::uint32_cref try_get_MDPriceLevel() const;
        mfast::int64_cref get_MDEntryTime() const;
        mfast::int64_cref try_get_MDEntryTime() const;
        mfast::uint64_cref get_TradeVolume() const;
        mfast::uint64_cref try_get_TradeVolume() const;
        mfast::decimal_cref get_GrossTradeAmt() const;
        mfast::decimal_cref try_get_GrossTradeAmt() const;
        mfast::uint32_cref get_NoTrades() const;
        mfast::uint32_cref try_get_NoTrades() const;
    };

    typedef mfast::make_sequence_cref<MDSshGrp_element_cref> MDSshGrp_cref;
    MDSshGrp_cref get_MDSshGrp() const;
    MDSshGrp_cref try_get_MDSshGrp() const;

};


typedef mfast::make_aggregate_mref<DepthSnapshot_cref> DepthSnapshot_mref_base;
class DepthSnapshot_mref
  : public DepthSnapshot_mref_base
{
  typedef DepthSnapshot_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<DepthSnapshot_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    DepthSnapshot_mref();
    template <typename T>
    DepthSnapshot_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, DepthSnapshot_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    DepthSnapshot_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit DepthSnapshot_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    void omit_MsgSeqNum() const;
    mfast::uint32_mref set_SenderCompID() const;
    mfast::uint32_mref set_LastMsgSeqNumProcessed() const;
    void omit_LastMsgSeqNumProcessed() const;
    mfast::uint32_mref set_RefreshIndicator() const;
    void omit_RefreshIndicator() const;
    mfast::uint32_mref set_MarketSegmentID() const;
    mfast::int64_mref set_SecurityID() const;
    mfast::uint32_mref set_ProductComplex() const;
    mfast::uint32_mref set_SecurityStatus() const;
    mfast::uint64_mref set_BidSize() const;
    mfast::uint64_mref set_OfferSize() const;
    mfast::int64_mref set_LastUpdateTime() const;

    class MDSshGrp_element_mref
      : public mfast::make_aggregate_mref<DepthSnapshot_cref::MDSshGrp_element_cref>
    {
      typedef mfast::make_aggregate_mref<DepthSnapshot_cref::MDSshGrp_element_cref> base_type;
      public:
        MDSshGrp_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_mref set_MDEntryType() const;
        mfast::uint32_mref set_TrdType() const;
        void omit_TrdType() const;
        mfast::uint32_mref set_TradingSessionID() const;
        void omit_TradingSessionID() const;
        mfast::uint32_mref set_TradingSessionSubID() const;
        void omit_TradingSessionSubID() const;
        mfast::uint32_mref set_FastMarketIndicator() const;
        void omit_FastMarketIndicator() const;
        mfast::uint32_mref set_SecurityTradingStatus() const;
        void omit_SecurityTradingStatus() const;
        mfast::uint64_mref set_TradeCondition() const;
        void omit_TradeCondition() const;
        mfast::decimal_mref set_MDEntryPx() const;
        void omit_MDEntryPx() const;
        mfast::decimal_mref set_Yield() const;
        void omit_Yield() const;
        mfast::decimal_mref set_PutYield() const;
        void omit_PutYield() const;
        mfast::decimal_mref set_CallYield() const;
        void omit_CallYield() const;
        mfast::uint32_mref set_MDEntrySize() const;
        void omit_MDEntrySize() const;
        mfast::uint32_mref set_NumberOfOrders() const;
        void omit_NumberOfOrders() const;
        mfast::uint32_mref set_MDPriceLevel() const;
        void omit_MDPriceLevel() const;
        mfast::int64_mref set_MDEntryTime() const;
        void omit_MDEntryTime() const;
        mfast::uint64_mref set_TradeVolume() const;
        void omit_TradeVolume() const;
        mfast::decimal_mref set_GrossTradeAmt() const;
        void omit_GrossTradeAmt() const;
        mfast::uint32_mref set_NoTrades() const;
        void omit_NoTrades() const;
    };

    typedef mfast::make_sequence_mref<MDSshGrp_element_mref> MDSshGrp_mref;
    MDSshGrp_mref set_MDSshGrp() const;
};

class DepthSnapshot
  : private mfast::value_storage_array<14>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 101
    };
    typedef mfast::template_instruction_ex<DepthSnapshot_cref> instruction_type;

    typedef mfast::make_message_cref<DepthSnapshot_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<DepthSnapshot_mref, instruction_type> mref_type;
    DepthSnapshot(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    DepthSnapshot(
      const DepthSnapshot_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit DepthSnapshot(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    DepthSnapshot(const DepthSnapshot&);
    DepthSnapshot& operator = (const DepthSnapshot&);
};


class IndexChange_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<IndexChange_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    IndexChange_cref();
    template <typename T>
    IndexChange_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, IndexChange_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    IndexChange_cref(const mfast::message_cref& other);

    explicit IndexChange_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MsgType() const;
    mfast::ascii_string_cref try_get_MsgType() const;

    class IndexChgGrp_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<IndexChgGrp_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        IndexChgGrp_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_cref get_Divisor() const;
        mfast::uint32_cref try_get_Divisor() const;
        mfast::uint32_cref get_IndexCode() const;
        mfast::uint32_cref try_get_IndexCode() const;
        mfast::uint32_cref get_IndexHigh() const;
        mfast::uint32_cref try_get_IndexHigh() const;
        mfast::uint32_cref get_IndexLow() const;
        mfast::uint32_cref try_get_IndexLow() const;
        mfast::uint32_cref get_IndexOpen() const;
        mfast::uint32_cref try_get_IndexOpen() const;
        mfast::uint32_cref get_PrevIndexClose() const;
        mfast::uint32_cref try_get_PrevIndexClose() const;
        mfast::uint32_cref get_IndexClose() const;
        mfast::uint32_cref try_get_IndexClose() const;
        mfast::uint32_cref get_IndexValue() const;
        mfast::uint32_cref try_get_IndexValue() const;
    };

    typedef mfast::make_sequence_cref<IndexChgGrp_element_cref> IndexChgGrp_cref;
    IndexChgGrp_cref get_IndexChgGrp() const;
    IndexChgGrp_cref try_get_IndexChgGrp() const;

};


typedef mfast::make_aggregate_mref<IndexChange_cref> IndexChange_mref_base;
class IndexChange_mref
  : public IndexChange_mref_base
{
  typedef IndexChange_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<IndexChange_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    IndexChange_mref();
    template <typename T>
    IndexChange_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, IndexChange_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    IndexChange_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit IndexChange_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);


    class IndexChgGrp_element_mref
      : public mfast::make_aggregate_mref<IndexChange_cref::IndexChgGrp_element_cref>
    {
      typedef mfast::make_aggregate_mref<IndexChange_cref::IndexChgGrp_element_cref> base_type;
      public:
        IndexChgGrp_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_mref set_Divisor() const;
        void omit_Divisor() const;
        mfast::uint32_mref set_IndexCode() const;
        mfast::uint32_mref set_IndexHigh() const;
        mfast::uint32_mref set_IndexLow() const;
        mfast::uint32_mref set_IndexOpen() const;
        mfast::uint32_mref set_PrevIndexClose() const;
        mfast::uint32_mref set_IndexClose() const;
        mfast::uint32_mref set_IndexValue() const;
    };

    typedef mfast::make_sequence_mref<IndexChgGrp_element_mref> IndexChgGrp_mref;
    IndexChgGrp_mref set_IndexChgGrp() const;
};

class IndexChange
  : private mfast::value_storage_array<2>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 51
    };
    typedef mfast::template_instruction_ex<IndexChange_cref> instruction_type;

    typedef mfast::make_message_cref<IndexChange_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<IndexChange_mref, instruction_type> mref_type;
    IndexChange(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    IndexChange(
      const IndexChange_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit IndexChange(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    IndexChange(const IndexChange&);
    IndexChange& operator = (const IndexChange&);
};


struct  templates_description
  : mfast::templates_description
{
  typedef std::tuple<MDPacketHeader,
                       ProductStateChange,
                       MassInstrumentStateChange,
                       InstrumentStateChange,
                       DepthIncremental,
                       ComplexInstrumentUpdate,
                       QuoteRequest,
                       CrossRequest,
                       DepthSnapshot,
                       IndexChange> types;
  templates_description();
  static const templates_description* instance();
};

inline const templates_description* description()
{
  return templates_description::instance();
}

#include "MDIFastTemplates_1_1.inl"
}
