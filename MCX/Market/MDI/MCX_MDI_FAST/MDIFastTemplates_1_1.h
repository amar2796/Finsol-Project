// MDIFastTemplates_1_1.h generated by mFAST from FAST Template. 
// Do not modify this file directly. Any modifications 
// will be lost the next time this file is generated.

#pragma once

#include <mfast.h>
namespace MDIFastTemplates_1_1
{

class MDPacketHeader_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<MDPacketHeader_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    MDPacketHeader_cref();
    template <typename T>
    MDPacketHeader_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, MDPacketHeader_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    MDPacketHeader_cref(const mfast::message_cref& other);

    explicit MDPacketHeader_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_cref get_SenderCompID() const;
    mfast::uint32_cref try_get_SenderCompID() const;
    mfast::byte_vector_cref get_PacketSeqNum() const;
    mfast::byte_vector_cref try_get_PacketSeqNum() const;
    mfast::byte_vector_cref get_SendingTime() const;
    mfast::byte_vector_cref try_get_SendingTime() const;

};


typedef mfast::make_aggregate_mref<MDPacketHeader_cref> MDPacketHeader_mref_base;
class MDPacketHeader_mref
  : public MDPacketHeader_mref_base
{
  typedef MDPacketHeader_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<MDPacketHeader_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    MDPacketHeader_mref();
    template <typename T>
    MDPacketHeader_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, MDPacketHeader_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    MDPacketHeader_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit MDPacketHeader_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_SenderCompID() const;
    mfast::byte_vector_mref set_PacketSeqNum() const;
    mfast::byte_vector_mref set_SendingTime() const;
};

class MDPacketHeader
  : private mfast::value_storage_array<3>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 65
    };
    typedef mfast::template_instruction_ex<MDPacketHeader_cref> instruction_type;

    typedef mfast::make_message_cref<MDPacketHeader_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<MDPacketHeader_mref, instruction_type> mref_type;
    MDPacketHeader(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    MDPacketHeader(
      const MDPacketHeader_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit MDPacketHeader(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    MDPacketHeader(const MDPacketHeader&);
    MDPacketHeader& operator = (const MDPacketHeader&);
};


class ProductStateChange_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<ProductStateChange_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    ProductStateChange_cref();
    template <typename T>
    ProductStateChange_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, ProductStateChange_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    ProductStateChange_cref(const mfast::message_cref& other);

    explicit ProductStateChange_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MsgType() const;
    mfast::ascii_string_cref try_get_MsgType() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint32_cref get_SenderCompID() const;
    mfast::uint32_cref try_get_SenderCompID() const;
    mfast::uint32_cref get_MarketSegmentID() const;
    mfast::uint32_cref try_get_MarketSegmentID() const;
    mfast::uint32_cref get_TradingSessionID() const;
    mfast::uint32_cref try_get_TradingSessionID() const;
    mfast::uint32_cref get_TradingSessionSubID() const;
    mfast::uint32_cref try_get_TradingSessionSubID() const;
    mfast::uint32_cref get_TradSesStatus() const;
    mfast::uint32_cref try_get_TradSesStatus() const;
    mfast::uint32_cref get_MarketCondition() const;
    mfast::uint32_cref try_get_MarketCondition() const;
    mfast::uint32_cref get_FastMarketIndicator() const;
    mfast::uint32_cref try_get_FastMarketIndicator() const;
    mfast::int64_cref get_TransactTime() const;
    mfast::int64_cref try_get_TransactTime() const;
    mfast::uint32_cref get_TESTradSesStatus() const;
    mfast::uint32_cref try_get_TESTradSesStatus() const;

};


typedef mfast::make_aggregate_mref<ProductStateChange_cref> ProductStateChange_mref_base;
class ProductStateChange_mref
  : public ProductStateChange_mref_base
{
  typedef ProductStateChange_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<ProductStateChange_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    ProductStateChange_mref();
    template <typename T>
    ProductStateChange_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, ProductStateChange_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    ProductStateChange_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit ProductStateChange_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    mfast::uint32_mref set_SenderCompID() const;
    mfast::uint32_mref set_MarketSegmentID() const;
    mfast::uint32_mref set_TradingSessionID() const;
    mfast::uint32_mref set_TradingSessionSubID() const;
    mfast::uint32_mref set_TradSesStatus() const;
    mfast::uint32_mref set_MarketCondition() const;
    void omit_MarketCondition() const;
    mfast::uint32_mref set_FastMarketIndicator() const;
    mfast::int64_mref set_TransactTime() const;
    mfast::uint32_mref set_TESTradSesStatus() const;
    void omit_TESTradSesStatus() const;
};

class ProductStateChange
  : private mfast::value_storage_array<11>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 108
    };
    typedef mfast::template_instruction_ex<ProductStateChange_cref> instruction_type;

    typedef mfast::make_message_cref<ProductStateChange_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<ProductStateChange_mref, instruction_type> mref_type;
    ProductStateChange(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    ProductStateChange(
      const ProductStateChange_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit ProductStateChange(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    ProductStateChange(const ProductStateChange&);
    ProductStateChange& operator = (const ProductStateChange&);
};


class MassInstrumentStateChange_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<MassInstrumentStateChange_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    MassInstrumentStateChange_cref();
    template <typename T>
    MassInstrumentStateChange_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, MassInstrumentStateChange_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    MassInstrumentStateChange_cref(const mfast::message_cref& other);

    explicit MassInstrumentStateChange_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MsgType() const;
    mfast::ascii_string_cref try_get_MsgType() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint32_cref get_SenderCompID() const;
    mfast::uint32_cref try_get_SenderCompID() const;
    mfast::uint32_cref get_MarketSegmentID() const;
    mfast::uint32_cref try_get_MarketSegmentID() const;
    mfast::uint32_cref get_InstrumentScopeProductComplex() const;
    mfast::uint32_cref try_get_InstrumentScopeProductComplex() const;
    mfast::uint32_cref get_SecurityMassStatus() const;
    mfast::uint32_cref try_get_SecurityMassStatus() const;
    mfast::uint32_cref get_SecurityMassTradingStatus() const;
    mfast::uint32_cref try_get_SecurityMassTradingStatus() const;
    mfast::uint32_cref get_MassMarketCondition() const;
    mfast::uint32_cref try_get_MassMarketCondition() const;
    mfast::uint32_cref get_FastMarketIndicator() const;
    mfast::uint32_cref try_get_FastMarketIndicator() const;
    mfast::uint32_cref get_SecurityMassTradingEvent() const;
    mfast::uint32_cref try_get_SecurityMassTradingEvent() const;
    mfast::uint32_cref get_MassSoldOutIndicator() const;
    mfast::uint32_cref try_get_MassSoldOutIndicator() const;
    mfast::int64_cref get_TransactTime() const;
    mfast::int64_cref try_get_TransactTime() const;
    mfast::uint32_cref get_TESSecurityMassStatus() const;
    mfast::uint32_cref try_get_TESSecurityMassStatus() const;

    class SecMassStatGrp_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<SecMassStatGrp_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        SecMassStatGrp_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::int64_cref get_SecurityID() const;
        mfast::int64_cref try_get_SecurityID() const;
        mfast::ascii_string_cref get_SecurityIDSource() const;
        mfast::ascii_string_cref try_get_SecurityIDSource() const;
        mfast::uint32_cref get_SecurityStatus() const;
        mfast::uint32_cref try_get_SecurityStatus() const;
        mfast::uint32_cref get_SecurityTradingStatus() const;
        mfast::uint32_cref try_get_SecurityTradingStatus() const;
        mfast::uint32_cref get_MarketCondition() const;
        mfast::uint32_cref try_get_MarketCondition() const;
        mfast::uint32_cref get_SecurityTradingEvent() const;
        mfast::uint32_cref try_get_SecurityTradingEvent() const;
        mfast::uint32_cref get_SoldOutIndicator() const;
        mfast::uint32_cref try_get_SoldOutIndicator() const;
        mfast::uint32_cref get_TESSecurityStatus() const;
        mfast::uint32_cref try_get_TESSecurityStatus() const;
    };

    typedef mfast::make_sequence_cref<SecMassStatGrp_element_cref> SecMassStatGrp_cref;
    SecMassStatGrp_cref get_SecMassStatGrp() const;
    SecMassStatGrp_cref try_get_SecMassStatGrp() const;
    mfast::uint32_cref get_LastFragment() const;
    mfast::uint32_cref try_get_LastFragment() const;

};


typedef mfast::make_aggregate_mref<MassInstrumentStateChange_cref> MassInstrumentStateChange_mref_base;
class MassInstrumentStateChange_mref
  : public MassInstrumentStateChange_mref_base
{
  typedef MassInstrumentStateChange_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<MassInstrumentStateChange_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    MassInstrumentStateChange_mref();
    template <typename T>
    MassInstrumentStateChange_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, MassInstrumentStateChange_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    MassInstrumentStateChange_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit MassInstrumentStateChange_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    mfast::uint32_mref set_SenderCompID() const;
    mfast::uint32_mref set_MarketSegmentID() const;
    mfast::uint32_mref set_InstrumentScopeProductComplex() const;
    mfast::uint32_mref set_SecurityMassStatus() const;
    mfast::uint32_mref set_SecurityMassTradingStatus() const;
    void omit_SecurityMassTradingStatus() const;
    mfast::uint32_mref set_MassMarketCondition() const;
    mfast::uint32_mref set_FastMarketIndicator() const;
    mfast::uint32_mref set_SecurityMassTradingEvent() const;
    void omit_SecurityMassTradingEvent() const;
    mfast::uint32_mref set_MassSoldOutIndicator() const;
    void omit_MassSoldOutIndicator() const;
    mfast::int64_mref set_TransactTime() const;
    mfast::uint32_mref set_TESSecurityMassStatus() const;
    void omit_TESSecurityMassStatus() const;

    class SecMassStatGrp_element_mref
      : public mfast::make_aggregate_mref<MassInstrumentStateChange_cref::SecMassStatGrp_element_cref>
    {
      typedef mfast::make_aggregate_mref<MassInstrumentStateChange_cref::SecMassStatGrp_element_cref> base_type;
      public:
        SecMassStatGrp_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::int64_mref set_SecurityID() const;
        mfast::uint32_mref set_SecurityStatus() const;
        mfast::uint32_mref set_SecurityTradingStatus() const;
        void omit_SecurityTradingStatus() const;
        mfast::uint32_mref set_MarketCondition() const;
        mfast::uint32_mref set_SecurityTradingEvent() const;
        void omit_SecurityTradingEvent() const;
        mfast::uint32_mref set_SoldOutIndicator() const;
        void omit_SoldOutIndicator() const;
        mfast::uint32_mref set_TESSecurityStatus() const;
        void omit_TESSecurityStatus() const;
    };

    typedef mfast::make_sequence_mref<SecMassStatGrp_element_mref> SecMassStatGrp_mref;
    SecMassStatGrp_mref set_SecMassStatGrp() const;
    mfast::uint32_mref set_LastFragment() const;
};

class MassInstrumentStateChange
  : private mfast::value_storage_array<15>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 104
    };
    typedef mfast::template_instruction_ex<MassInstrumentStateChange_cref> instruction_type;

    typedef mfast::make_message_cref<MassInstrumentStateChange_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<MassInstrumentStateChange_mref, instruction_type> mref_type;
    MassInstrumentStateChange(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    MassInstrumentStateChange(
      const MassInstrumentStateChange_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit MassInstrumentStateChange(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    MassInstrumentStateChange(const MassInstrumentStateChange&);
    MassInstrumentStateChange& operator = (const MassInstrumentStateChange&);
};


class InstrumentStateChange_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<InstrumentStateChange_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    InstrumentStateChange_cref();
    template <typename T>
    InstrumentStateChange_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, InstrumentStateChange_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    InstrumentStateChange_cref(const mfast::message_cref& other);

    explicit InstrumentStateChange_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MsgType() const;
    mfast::ascii_string_cref try_get_MsgType() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint32_cref get_SenderCompID() const;
    mfast::uint32_cref try_get_SenderCompID() const;
    mfast::uint32_cref get_MarketSegmentID() const;
    mfast::uint32_cref try_get_MarketSegmentID() const;
    mfast::int64_cref get_SecurityID() const;
    mfast::int64_cref try_get_SecurityID() const;
    mfast::ascii_string_cref get_SecurityIDSource() const;
    mfast::ascii_string_cref try_get_SecurityIDSource() const;
    mfast::uint32_cref get_SecurityStatus() const;
    mfast::uint32_cref try_get_SecurityStatus() const;
    mfast::uint32_cref get_SecurityTradingStatus() const;
    mfast::uint32_cref try_get_SecurityTradingStatus() const;
    mfast::uint32_cref get_MarketCondition() const;
    mfast::uint32_cref try_get_MarketCondition() const;
    mfast::uint32_cref get_FastMarketIndicator() const;
    mfast::uint32_cref try_get_FastMarketIndicator() const;
    mfast::uint32_cref get_SecurityTradingEvent() const;
    mfast::uint32_cref try_get_SecurityTradingEvent() const;
    mfast::uint32_cref get_SoldOutIndicator() const;
    mfast::uint32_cref try_get_SoldOutIndicator() const;
    mfast::int64_cref get_TransactTime() const;
    mfast::int64_cref try_get_TransactTime() const;
    mfast::uint32_cref get_TESSecurityStatus() const;
    mfast::uint32_cref try_get_TESSecurityStatus() const;

};


typedef mfast::make_aggregate_mref<InstrumentStateChange_cref> InstrumentStateChange_mref_base;
class InstrumentStateChange_mref
  : public InstrumentStateChange_mref_base
{
  typedef InstrumentStateChange_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<InstrumentStateChange_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    InstrumentStateChange_mref();
    template <typename T>
    InstrumentStateChange_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, InstrumentStateChange_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    InstrumentStateChange_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit InstrumentStateChange_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    mfast::uint32_mref set_SenderCompID() const;
    mfast::uint32_mref set_MarketSegmentID() const;
    mfast::int64_mref set_SecurityID() const;
    mfast::uint32_mref set_SecurityStatus() const;
    mfast::uint32_mref set_SecurityTradingStatus() const;
    void omit_SecurityTradingStatus() const;
    mfast::uint32_mref set_MarketCondition() const;
    mfast::uint32_mref set_FastMarketIndicator() const;
    mfast::uint32_mref set_SecurityTradingEvent() const;
    void omit_SecurityTradingEvent() const;
    mfast::uint32_mref set_SoldOutIndicator() const;
    void omit_SoldOutIndicator() const;
    mfast::int64_mref set_TransactTime() const;
    mfast::uint32_mref set_TESSecurityStatus() const;
    void omit_TESSecurityStatus() const;
};

class InstrumentStateChange
  : private mfast::value_storage_array<14>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 103
    };
    typedef mfast::template_instruction_ex<InstrumentStateChange_cref> instruction_type;

    typedef mfast::make_message_cref<InstrumentStateChange_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<InstrumentStateChange_mref, instruction_type> mref_type;
    InstrumentStateChange(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    InstrumentStateChange(
      const InstrumentStateChange_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit InstrumentStateChange(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    InstrumentStateChange(const InstrumentStateChange&);
    InstrumentStateChange& operator = (const InstrumentStateChange&);
};


class DepthIncremental_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<DepthIncremental_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    DepthIncremental_cref();
    template <typename T>
    DepthIncremental_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, DepthIncremental_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    DepthIncremental_cref(const mfast::message_cref& other);

    explicit DepthIncremental_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MsgType() const;
    mfast::ascii_string_cref try_get_MsgType() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint32_cref get_SenderCompID() const;
    mfast::uint32_cref try_get_SenderCompID() const;
    mfast::uint32_cref get_MarketSegmentID() const;
    mfast::uint32_cref try_get_MarketSegmentID() const;

    class MDIncGrp_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<MDIncGrp_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        MDIncGrp_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_cref get_MDOriginType() const;
        mfast::uint32_cref try_get_MDOriginType() const;
        mfast::uint32_cref get_MDUpdateAction() const;
        mfast::uint32_cref try_get_MDUpdateAction() const;
        mfast::uint32_cref get_MDEntryType() const;
        mfast::uint32_cref try_get_MDEntryType() const;
        mfast::int64_cref get_SecurityID() const;
        mfast::int64_cref try_get_SecurityID() const;
        mfast::ascii_string_cref get_SecurityIDSource() const;
        mfast::ascii_string_cref try_get_SecurityIDSource() const;
        mfast::decimal_cref get_MDEntryPx() const;
        mfast::decimal_cref try_get_MDEntryPx() const;
        mfast::decimal_cref get_MDEntrySize() const;
        mfast::decimal_cref try_get_MDEntrySize() const;
        mfast::uint32_cref get_NumberOfOrders() const;
        mfast::uint32_cref try_get_NumberOfOrders() const;
        mfast::uint32_cref get_MDPriceLevel() const;
        mfast::uint32_cref try_get_MDPriceLevel() const;
        mfast::int64_cref get_MDEntryTime() const;
        mfast::int64_cref try_get_MDEntryTime() const;
        mfast::uint32_cref get_PotentialSecurityTradingEvent() const;
        mfast::uint32_cref try_get_PotentialSecurityTradingEvent() const;
        mfast::uint32_cref get_QuoteCondition() const;
        mfast::uint32_cref try_get_QuoteCondition() const;
        mfast::decimal_cref get_TotalBuyQuantity() const;
        mfast::decimal_cref try_get_TotalBuyQuantity() const;
        mfast::decimal_cref get_TotalSellQuantity() const;
        mfast::decimal_cref try_get_TotalSellQuantity() const;

        class TradeEntryGrp_cref
          : public mfast::aggregate_cref
        {
          typedef mfast::aggregate_cref base_type;
          public:
            typedef mfast::group_instruction_ex<TradeEntryGrp_cref> instruction_type;

            typedef const instruction_type* instruction_cptr;
            TradeEntryGrp_cref();
            template <typename T>
            TradeEntryGrp_cref(
              typename std::enable_if<std::is_same<typename T::cref_type, TradeEntryGrp_cref>::value, const mfast::value_storage*>::type storage,
              const T* instruction);

            explicit TradeEntryGrp_cref(const mfast::field_cref& other);

            template <typename Visitor>
            void accept(Visitor& v);

            mfast::uint32_cref get_TrdType() const;
            mfast::uint32_cref try_get_TrdType() const;
            mfast::uint32_cref get_AlgorithmicTradeIndicator() const;
            mfast::uint32_cref try_get_AlgorithmicTradeIndicator() const;
            mfast::uint64_cref get_TradeCondition() const;
            mfast::uint64_cref try_get_TradeCondition() const;
            mfast::uint32_cref get_MultiLegReportingType() const;
            mfast::uint32_cref try_get_MultiLegReportingType() const;
            mfast::uint32_cref get_MultiLegPriceModel() const;
            mfast::uint32_cref try_get_MultiLegPriceModel() const;
            mfast::int64_cref get_AggressorTime() const;
            mfast::int64_cref try_get_AggressorTime() const;
            mfast::int64_cref get_RequestTime() const;
            mfast::int64_cref try_get_RequestTime() const;
            mfast::uint32_cref get_AggressorSide() const;
            mfast::uint32_cref try_get_AggressorSide() const;
            mfast::uint32_cref get_NumberOfBuyOrders() const;
            mfast::uint32_cref try_get_NumberOfBuyOrders() const;
            mfast::uint32_cref get_NumberOfSellOrders() const;
            mfast::uint32_cref try_get_NumberOfSellOrders() const;
            mfast::uint32_cref get_TotalNumOfTrades() const;
            mfast::uint32_cref try_get_TotalNumOfTrades() const;
            mfast::decimal_cref get_RestingCxlQty() const;
            mfast::decimal_cref try_get_RestingCxlQty() const;
            mfast::uint32_cref get_MDEntryID() const;
            mfast::uint32_cref try_get_MDEntryID() const;
            mfast::decimal_cref get_TotalTradedValue() const;
            mfast::decimal_cref try_get_TotalTradedValue() const;
            mfast::decimal_cref get_AverageTradedPrice() const;
            mfast::decimal_cref try_get_AverageTradedPrice() const;
            mfast::decimal_cref get_NonDisclosedTradeVolume() const;
            mfast::decimal_cref try_get_NonDisclosedTradeVolume() const;
        };

        TradeEntryGrp_cref get_TradeEntryGrp() const;
        TradeEntryGrp_cref try_get_TradeEntryGrp() const;
    };

    typedef mfast::make_sequence_cref<MDIncGrp_element_cref> MDIncGrp_cref;
    MDIncGrp_cref get_MDIncGrp() const;
    MDIncGrp_cref try_get_MDIncGrp() const;

};


typedef mfast::make_aggregate_mref<DepthIncremental_cref> DepthIncremental_mref_base;
class DepthIncremental_mref
  : public DepthIncremental_mref_base
{
  typedef DepthIncremental_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<DepthIncremental_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    DepthIncremental_mref();
    template <typename T>
    DepthIncremental_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, DepthIncremental_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    DepthIncremental_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit DepthIncremental_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    mfast::uint32_mref set_SenderCompID() const;
    mfast::uint32_mref set_MarketSegmentID() const;

    class MDIncGrp_element_mref
      : public mfast::make_aggregate_mref<DepthIncremental_cref::MDIncGrp_element_cref>
    {
      typedef mfast::make_aggregate_mref<DepthIncremental_cref::MDIncGrp_element_cref> base_type;
      public:
        MDIncGrp_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_mref set_MDOriginType() const;
        mfast::uint32_mref set_MDUpdateAction() const;
        mfast::uint32_mref set_MDEntryType() const;
        mfast::int64_mref set_SecurityID() const;
        mfast::decimal_mref set_MDEntryPx() const;
        void omit_MDEntryPx() const;
        mfast::decimal_mref set_MDEntrySize() const;
        void omit_MDEntrySize() const;
        mfast::uint32_mref set_NumberOfOrders() const;
        void omit_NumberOfOrders() const;
        mfast::uint32_mref set_MDPriceLevel() const;
        void omit_MDPriceLevel() const;
        mfast::int64_mref set_MDEntryTime() const;
        void omit_MDEntryTime() const;
        mfast::uint32_mref set_PotentialSecurityTradingEvent() const;
        void omit_PotentialSecurityTradingEvent() const;
        mfast::uint32_mref set_QuoteCondition() const;
        void omit_QuoteCondition() const;
        mfast::decimal_mref set_TotalBuyQuantity() const;
        void omit_TotalBuyQuantity() const;
        mfast::decimal_mref set_TotalSellQuantity() const;
        void omit_TotalSellQuantity() const;

        class TradeEntryGrp_mref
          : public mfast::make_aggregate_mref<DepthIncremental_cref::MDIncGrp_element_cref::TradeEntryGrp_cref>
        {
          typedef mfast::make_aggregate_mref<DepthIncremental_cref::MDIncGrp_element_cref::TradeEntryGrp_cref> base_type;
          public:
            TradeEntryGrp_mref();
            template <typename T>
            TradeEntryGrp_mref(
              mfast::allocator*       alloc,
              typename std::enable_if<std::is_same<typename T::cref_type, TradeEntryGrp_cref>::value, mfast::value_storage*>::type   storage,
              const T* instruction);

            explicit TradeEntryGrp_mref(const mfast::field_mref_base& other);

            template <typename Visitor>
            void accept(Visitor& v);

            mfast::uint32_mref set_TrdType() const;
            void omit_TrdType() const;
            mfast::uint32_mref set_AlgorithmicTradeIndicator() const;
            void omit_AlgorithmicTradeIndicator() const;
            mfast::uint64_mref set_TradeCondition() const;
            void omit_TradeCondition() const;
            mfast::uint32_mref set_MultiLegReportingType() const;
            void omit_MultiLegReportingType() const;
            mfast::uint32_mref set_MultiLegPriceModel() const;
            void omit_MultiLegPriceModel() const;
            mfast::int64_mref set_AggressorTime() const;
            void omit_AggressorTime() const;
            mfast::int64_mref set_RequestTime() const;
            void omit_RequestTime() const;
            mfast::uint32_mref set_AggressorSide() const;
            void omit_AggressorSide() const;
            mfast::uint32_mref set_NumberOfBuyOrders() const;
            void omit_NumberOfBuyOrders() const;
            mfast::uint32_mref set_NumberOfSellOrders() const;
            void omit_NumberOfSellOrders() const;
            mfast::uint32_mref set_TotalNumOfTrades() const;
            void omit_TotalNumOfTrades() const;
            mfast::decimal_mref set_RestingCxlQty() const;
            void omit_RestingCxlQty() const;
            mfast::uint32_mref set_MDEntryID() const;
            void omit_MDEntryID() const;
            mfast::decimal_mref set_TotalTradedValue() const;
            void omit_TotalTradedValue() const;
            mfast::decimal_mref set_AverageTradedPrice() const;
            void omit_AverageTradedPrice() const;
            mfast::decimal_mref set_NonDisclosedTradeVolume() const;
            void omit_NonDisclosedTradeVolume() const;
        };

        TradeEntryGrp_mref set_TradeEntryGrp() const;
        void omit_TradeEntryGrp() const;
    };

    typedef mfast::make_sequence_mref<MDIncGrp_element_mref> MDIncGrp_mref;
    MDIncGrp_mref set_MDIncGrp() const;
};

class DepthIncremental
  : private mfast::value_storage_array<5>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 102
    };
    typedef mfast::template_instruction_ex<DepthIncremental_cref> instruction_type;

    typedef mfast::make_message_cref<DepthIncremental_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<DepthIncremental_mref, instruction_type> mref_type;
    DepthIncremental(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    DepthIncremental(
      const DepthIncremental_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit DepthIncremental(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    DepthIncremental(const DepthIncremental&);
    DepthIncremental& operator = (const DepthIncremental&);
};


class ComplexInstrumentUpdate_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<ComplexInstrumentUpdate_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    ComplexInstrumentUpdate_cref();
    template <typename T>
    ComplexInstrumentUpdate_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, ComplexInstrumentUpdate_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    ComplexInstrumentUpdate_cref(const mfast::message_cref& other);

    explicit ComplexInstrumentUpdate_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MsgType() const;
    mfast::ascii_string_cref try_get_MsgType() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint32_cref get_SenderCompID() const;
    mfast::uint32_cref try_get_SenderCompID() const;
    mfast::ascii_string_cref get_SecurityUpdateAction() const;
    mfast::ascii_string_cref try_get_SecurityUpdateAction() const;
    mfast::int64_cref get_SecurityID() const;
    mfast::int64_cref try_get_SecurityID() const;
    mfast::ascii_string_cref get_SecurityIDSource() const;
    mfast::ascii_string_cref try_get_SecurityIDSource() const;
    mfast::ascii_string_cref get_SecurityDesc() const;
    mfast::ascii_string_cref try_get_SecurityDesc() const;
    mfast::uint32_cref get_SecurityType() const;
    mfast::uint32_cref try_get_SecurityType() const;
    mfast::uint32_cref get_SecuritySubType() const;
    mfast::uint32_cref try_get_SecuritySubType() const;
    mfast::uint32_cref get_ProductComplex() const;
    mfast::uint32_cref try_get_ProductComplex() const;
    mfast::uint32_cref get_LegRatioMultiplier() const;
    mfast::uint32_cref try_get_LegRatioMultiplier() const;

    class InstrmtLegGrp_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<InstrmtLegGrp_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        InstrmtLegGrp_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_cref get_LegSymbol() const;
        mfast::uint32_cref try_get_LegSymbol() const;
        mfast::int64_cref get_LegSecurityID() const;
        mfast::int64_cref try_get_LegSecurityID() const;
        mfast::ascii_string_cref get_LegSecurityIDSource() const;
        mfast::ascii_string_cref try_get_LegSecurityIDSource() const;
        mfast::uint32_cref get_LegSecurityType() const;
        mfast::uint32_cref try_get_LegSecurityType() const;
        mfast::uint32_cref get_LegRatioQty() const;
        mfast::uint32_cref try_get_LegRatioQty() const;
        mfast::uint32_cref get_LegSide() const;
        mfast::uint32_cref try_get_LegSide() const;
        mfast::decimal_cref get_LegPrice() const;
        mfast::decimal_cref try_get_LegPrice() const;
    };

    typedef mfast::make_sequence_cref<InstrmtLegGrp_element_cref> InstrmtLegGrp_cref;
    InstrmtLegGrp_cref get_InstrmtLegGrp() const;
    InstrmtLegGrp_cref try_get_InstrmtLegGrp() const;

    class MarketSegmentGrp_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<MarketSegmentGrp_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        MarketSegmentGrp_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_cref get_MarketSegmentID() const;
        mfast::uint32_cref try_get_MarketSegmentID() const;
        mfast::uint32_cref get_ImpliedMarketIndicator() const;
        mfast::uint32_cref try_get_ImpliedMarketIndicator() const;
    };

    typedef mfast::make_sequence_cref<MarketSegmentGrp_element_cref> MarketSegmentGrp_cref;
    MarketSegmentGrp_cref get_MarketSegmentGrp() const;
    MarketSegmentGrp_cref try_get_MarketSegmentGrp() const;
    mfast::int64_cref get_TransactTime() const;
    mfast::int64_cref try_get_TransactTime() const;

};


typedef mfast::make_aggregate_mref<ComplexInstrumentUpdate_cref> ComplexInstrumentUpdate_mref_base;
class ComplexInstrumentUpdate_mref
  : public ComplexInstrumentUpdate_mref_base
{
  typedef ComplexInstrumentUpdate_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<ComplexInstrumentUpdate_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    ComplexInstrumentUpdate_mref();
    template <typename T>
    ComplexInstrumentUpdate_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, ComplexInstrumentUpdate_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    ComplexInstrumentUpdate_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit ComplexInstrumentUpdate_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    mfast::uint32_mref set_SenderCompID() const;
    mfast::int64_mref set_SecurityID() const;
    mfast::ascii_string_mref set_SecurityDesc() const;
    mfast::uint32_mref set_SecuritySubType() const;
    void omit_SecuritySubType() const;
    mfast::uint32_mref set_ProductComplex() const;
    mfast::uint32_mref set_LegRatioMultiplier() const;
    void omit_LegRatioMultiplier() const;

    class InstrmtLegGrp_element_mref
      : public mfast::make_aggregate_mref<ComplexInstrumentUpdate_cref::InstrmtLegGrp_element_cref>
    {
      typedef mfast::make_aggregate_mref<ComplexInstrumentUpdate_cref::InstrmtLegGrp_element_cref> base_type;
      public:
        InstrmtLegGrp_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_mref set_LegSymbol() const;
        mfast::int64_mref set_LegSecurityID() const;
        mfast::uint32_mref set_LegSecurityType() const;
        mfast::uint32_mref set_LegRatioQty() const;
        mfast::uint32_mref set_LegSide() const;
        mfast::decimal_mref set_LegPrice() const;
        void omit_LegPrice() const;
    };

    typedef mfast::make_sequence_mref<InstrmtLegGrp_element_mref> InstrmtLegGrp_mref;
    InstrmtLegGrp_mref set_InstrmtLegGrp() const;

    class MarketSegmentGrp_element_mref
      : public mfast::make_aggregate_mref<ComplexInstrumentUpdate_cref::MarketSegmentGrp_element_cref>
    {
      typedef mfast::make_aggregate_mref<ComplexInstrumentUpdate_cref::MarketSegmentGrp_element_cref> base_type;
      public:
        MarketSegmentGrp_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_mref set_MarketSegmentID() const;
        mfast::uint32_mref set_ImpliedMarketIndicator() const;
    };

    typedef mfast::make_sequence_mref<MarketSegmentGrp_element_mref> MarketSegmentGrp_mref;
    MarketSegmentGrp_mref set_MarketSegmentGrp() const;
    mfast::int64_mref set_TransactTime() const;
};

class ComplexInstrumentUpdate
  : private mfast::value_storage_array<14>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 105
    };
    typedef mfast::template_instruction_ex<ComplexInstrumentUpdate_cref> instruction_type;

    typedef mfast::make_message_cref<ComplexInstrumentUpdate_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<ComplexInstrumentUpdate_mref, instruction_type> mref_type;
    ComplexInstrumentUpdate(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    ComplexInstrumentUpdate(
      const ComplexInstrumentUpdate_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit ComplexInstrumentUpdate(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    ComplexInstrumentUpdate(const ComplexInstrumentUpdate&);
    ComplexInstrumentUpdate& operator = (const ComplexInstrumentUpdate&);
};


class QuoteRequest_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<QuoteRequest_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    QuoteRequest_cref();
    template <typename T>
    QuoteRequest_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, QuoteRequest_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    QuoteRequest_cref(const mfast::message_cref& other);

    explicit QuoteRequest_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MsgType() const;
    mfast::ascii_string_cref try_get_MsgType() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint32_cref get_SenderCompID() const;
    mfast::uint32_cref try_get_SenderCompID() const;
    mfast::uint32_cref get_MarketSegmentID() const;
    mfast::uint32_cref try_get_MarketSegmentID() const;

    class QuotReqGrp_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<QuotReqGrp_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        QuotReqGrp_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::int64_cref get_SecurityID() const;
        mfast::int64_cref try_get_SecurityID() const;
        mfast::ascii_string_cref get_SecurityIDSource() const;
        mfast::ascii_string_cref try_get_SecurityIDSource() const;
        mfast::uint32_cref get_Side() const;
        mfast::uint32_cref try_get_Side() const;
        mfast::decimal_cref get_OrderQty() const;
        mfast::decimal_cref try_get_OrderQty() const;
        mfast::int64_cref get_TransactTime() const;
        mfast::int64_cref try_get_TransactTime() const;
    };

    typedef mfast::make_sequence_cref<QuotReqGrp_element_cref> QuotReqGrp_cref;
    QuotReqGrp_cref get_QuotReqGrp() const;
    QuotReqGrp_cref try_get_QuotReqGrp() const;

};


typedef mfast::make_aggregate_mref<QuoteRequest_cref> QuoteRequest_mref_base;
class QuoteRequest_mref
  : public QuoteRequest_mref_base
{
  typedef QuoteRequest_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<QuoteRequest_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    QuoteRequest_mref();
    template <typename T>
    QuoteRequest_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, QuoteRequest_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    QuoteRequest_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit QuoteRequest_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    mfast::uint32_mref set_SenderCompID() const;
    mfast::uint32_mref set_MarketSegmentID() const;

    class QuotReqGrp_element_mref
      : public mfast::make_aggregate_mref<QuoteRequest_cref::QuotReqGrp_element_cref>
    {
      typedef mfast::make_aggregate_mref<QuoteRequest_cref::QuotReqGrp_element_cref> base_type;
      public:
        QuotReqGrp_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::int64_mref set_SecurityID() const;
        mfast::uint32_mref set_Side() const;
        void omit_Side() const;
        mfast::decimal_mref set_OrderQty() const;
        void omit_OrderQty() const;
        mfast::int64_mref set_TransactTime() const;
    };

    typedef mfast::make_sequence_mref<QuotReqGrp_element_mref> QuotReqGrp_mref;
    QuotReqGrp_mref set_QuotReqGrp() const;
};

class QuoteRequest
  : private mfast::value_storage_array<5>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 106
    };
    typedef mfast::template_instruction_ex<QuoteRequest_cref> instruction_type;

    typedef mfast::make_message_cref<QuoteRequest_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<QuoteRequest_mref, instruction_type> mref_type;
    QuoteRequest(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    QuoteRequest(
      const QuoteRequest_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit QuoteRequest(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    QuoteRequest(const QuoteRequest&);
    QuoteRequest& operator = (const QuoteRequest&);
};


class CrossRequest_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<CrossRequest_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    CrossRequest_cref();
    template <typename T>
    CrossRequest_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, CrossRequest_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    CrossRequest_cref(const mfast::message_cref& other);

    explicit CrossRequest_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MsgType() const;
    mfast::ascii_string_cref try_get_MsgType() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint32_cref get_SenderCompID() const;
    mfast::uint32_cref try_get_SenderCompID() const;
    mfast::uint32_cref get_MarketSegmentID() const;
    mfast::uint32_cref try_get_MarketSegmentID() const;
    mfast::int64_cref get_SecurityID() const;
    mfast::int64_cref try_get_SecurityID() const;
    mfast::ascii_string_cref get_SecurityIDSource() const;
    mfast::ascii_string_cref try_get_SecurityIDSource() const;
    mfast::decimal_cref get_OrderQty() const;
    mfast::decimal_cref try_get_OrderQty() const;
    mfast::uint32_cref get_CrossRequestType() const;
    mfast::uint32_cref try_get_CrossRequestType() const;

    class CrossRequestSideGrp_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<CrossRequestSideGrp_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        CrossRequestSideGrp_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_cref get_Side() const;
        mfast::uint32_cref try_get_Side() const;
        mfast::uint32_cref get_InputSource() const;
        mfast::uint32_cref try_get_InputSource() const;
    };

    typedef mfast::make_sequence_cref<CrossRequestSideGrp_element_cref> CrossRequestSideGrp_cref;
    CrossRequestSideGrp_cref get_CrossRequestSideGrp() const;
    CrossRequestSideGrp_cref try_get_CrossRequestSideGrp() const;
    mfast::decimal_cref get_MDEntryPx() const;
    mfast::decimal_cref try_get_MDEntryPx() const;
    mfast::int64_cref get_TransactTime() const;
    mfast::int64_cref try_get_TransactTime() const;

};


typedef mfast::make_aggregate_mref<CrossRequest_cref> CrossRequest_mref_base;
class CrossRequest_mref
  : public CrossRequest_mref_base
{
  typedef CrossRequest_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<CrossRequest_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    CrossRequest_mref();
    template <typename T>
    CrossRequest_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, CrossRequest_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    CrossRequest_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit CrossRequest_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    mfast::uint32_mref set_SenderCompID() const;
    mfast::uint32_mref set_MarketSegmentID() const;
    mfast::int64_mref set_SecurityID() const;
    mfast::decimal_mref set_OrderQty() const;
    void omit_OrderQty() const;
    mfast::uint32_mref set_CrossRequestType() const;

    class CrossRequestSideGrp_element_mref
      : public mfast::make_aggregate_mref<CrossRequest_cref::CrossRequestSideGrp_element_cref>
    {
      typedef mfast::make_aggregate_mref<CrossRequest_cref::CrossRequestSideGrp_element_cref> base_type;
      public:
        CrossRequestSideGrp_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_mref set_Side() const;
        void omit_Side() const;
    };

    typedef mfast::make_sequence_mref<CrossRequestSideGrp_element_mref> CrossRequestSideGrp_mref;
    CrossRequestSideGrp_mref set_CrossRequestSideGrp() const;
    void omit_CrossRequestSideGrp() const;
    mfast::decimal_mref set_MDEntryPx() const;
    void omit_MDEntryPx() const;
    mfast::int64_mref set_TransactTime() const;
};

class CrossRequest
  : private mfast::value_storage_array<11>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 107
    };
    typedef mfast::template_instruction_ex<CrossRequest_cref> instruction_type;

    typedef mfast::make_message_cref<CrossRequest_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<CrossRequest_mref, instruction_type> mref_type;
    CrossRequest(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    CrossRequest(
      const CrossRequest_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit CrossRequest(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    CrossRequest(const CrossRequest&);
    CrossRequest& operator = (const CrossRequest&);
};


class DepthSnapshot_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<DepthSnapshot_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    DepthSnapshot_cref();
    template <typename T>
    DepthSnapshot_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, DepthSnapshot_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    DepthSnapshot_cref(const mfast::message_cref& other);

    explicit DepthSnapshot_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MsgType() const;
    mfast::ascii_string_cref try_get_MsgType() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint32_cref get_SenderCompID() const;
    mfast::uint32_cref try_get_SenderCompID() const;
    mfast::uint32_cref get_LastMsgSeqNumProcessed() const;
    mfast::uint32_cref try_get_LastMsgSeqNumProcessed() const;
    mfast::uint32_cref get_RefreshIndicator() const;
    mfast::uint32_cref try_get_RefreshIndicator() const;
    mfast::uint32_cref get_MarketSegmentID() const;
    mfast::uint32_cref try_get_MarketSegmentID() const;
    mfast::int64_cref get_SecurityID() const;
    mfast::int64_cref try_get_SecurityID() const;
    mfast::ascii_string_cref get_SecurityIDSource() const;
    mfast::ascii_string_cref try_get_SecurityIDSource() const;
    mfast::uint32_cref get_ProductComplex() const;
    mfast::uint32_cref try_get_ProductComplex() const;
    mfast::uint32_cref get_SecurityStatus() const;
    mfast::uint32_cref try_get_SecurityStatus() const;
    mfast::uint32_cref get_TESSecurityStatus() const;
    mfast::uint32_cref try_get_TESSecurityStatus() const;
    mfast::int64_cref get_LastUpdateTime() const;
    mfast::int64_cref try_get_LastUpdateTime() const;
    mfast::decimal_cref get_TotalBuyQuantity() const;
    mfast::decimal_cref try_get_TotalBuyQuantity() const;
    mfast::decimal_cref get_TotalSellQuantity() const;
    mfast::decimal_cref try_get_TotalSellQuantity() const;

    class MDSshGrp_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<MDSshGrp_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        MDSshGrp_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_cref get_MDOriginType() const;
        mfast::uint32_cref try_get_MDOriginType() const;
        mfast::uint32_cref get_MDEntryType() const;
        mfast::uint32_cref try_get_MDEntryType() const;
        mfast::uint32_cref get_MDBookType() const;
        mfast::uint32_cref try_get_MDBookType() const;
        mfast::uint32_cref get_MDSubBookType() const;
        mfast::uint32_cref try_get_MDSubBookType() const;
        mfast::uint32_cref get_TrdType() const;
        mfast::uint32_cref try_get_TrdType() const;
        mfast::uint32_cref get_TradingSessionID() const;
        mfast::uint32_cref try_get_TradingSessionID() const;
        mfast::uint32_cref get_TradingSessionSubID() const;
        mfast::uint32_cref try_get_TradingSessionSubID() const;
        mfast::uint32_cref get_TESTradSesStatus() const;
        mfast::uint32_cref try_get_TESTradSesStatus() const;
        mfast::uint32_cref get_SecurityTradingStatus() const;
        mfast::uint32_cref try_get_SecurityTradingStatus() const;
        mfast::uint32_cref get_MarketCondition() const;
        mfast::uint32_cref try_get_MarketCondition() const;
        mfast::uint32_cref get_FastMarketIndicator() const;
        mfast::uint32_cref try_get_FastMarketIndicator() const;
        mfast::uint32_cref get_SecurityTradingEvent() const;
        mfast::uint32_cref try_get_SecurityTradingEvent() const;
        mfast::uint32_cref get_PotentialSecurityTradingEvent() const;
        mfast::uint32_cref try_get_PotentialSecurityTradingEvent() const;
        mfast::uint32_cref get_SoldOutIndicator() const;
        mfast::uint32_cref try_get_SoldOutIndicator() const;
        mfast::uint64_cref get_TradeCondition() const;
        mfast::uint64_cref try_get_TradeCondition() const;
        mfast::uint32_cref get_MultiLegReportingType() const;
        mfast::uint32_cref try_get_MultiLegReportingType() const;
        mfast::uint32_cref get_MultiLegPriceModel() const;
        mfast::uint32_cref try_get_MultiLegPriceModel() const;
        mfast::uint32_cref get_QuoteCondition() const;
        mfast::uint32_cref try_get_QuoteCondition() const;
        mfast::decimal_cref get_MDEntryPx() const;
        mfast::decimal_cref try_get_MDEntryPx() const;
        mfast::decimal_cref get_MDEntrySize() const;
        mfast::decimal_cref try_get_MDEntrySize() const;
        mfast::uint32_cref get_NumberOfOrders() const;
        mfast::uint32_cref try_get_NumberOfOrders() const;
        mfast::uint32_cref get_MDPriceLevel() const;
        mfast::uint32_cref try_get_MDPriceLevel() const;
        mfast::int64_cref get_MDEntryTime() const;
        mfast::int64_cref try_get_MDEntryTime() const;
        mfast::decimal_cref get_NonDisclosedTradeVolume() const;
        mfast::decimal_cref try_get_NonDisclosedTradeVolume() const;
        mfast::decimal_cref get_TotalTradedValue() const;
        mfast::decimal_cref try_get_TotalTradedValue() const;
        mfast::decimal_cref get_AverageTradedPrice() const;
        mfast::decimal_cref try_get_AverageTradedPrice() const;
        mfast::uint32_cref get_TotalNumOfTrades() const;
        mfast::uint32_cref try_get_TotalNumOfTrades() const;
    };

    typedef mfast::make_sequence_cref<MDSshGrp_element_cref> MDSshGrp_cref;
    MDSshGrp_cref get_MDSshGrp() const;
    MDSshGrp_cref try_get_MDSshGrp() const;

};


typedef mfast::make_aggregate_mref<DepthSnapshot_cref> DepthSnapshot_mref_base;
class DepthSnapshot_mref
  : public DepthSnapshot_mref_base
{
  typedef DepthSnapshot_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<DepthSnapshot_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    DepthSnapshot_mref();
    template <typename T>
    DepthSnapshot_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, DepthSnapshot_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    DepthSnapshot_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit DepthSnapshot_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    void omit_MsgSeqNum() const;
    mfast::uint32_mref set_SenderCompID() const;
    mfast::uint32_mref set_LastMsgSeqNumProcessed() const;
    void omit_LastMsgSeqNumProcessed() const;
    mfast::uint32_mref set_RefreshIndicator() const;
    void omit_RefreshIndicator() const;
    mfast::uint32_mref set_MarketSegmentID() const;
    mfast::int64_mref set_SecurityID() const;
    mfast::uint32_mref set_ProductComplex() const;
    mfast::uint32_mref set_SecurityStatus() const;
    mfast::uint32_mref set_TESSecurityStatus() const;
    void omit_TESSecurityStatus() const;
    mfast::int64_mref set_LastUpdateTime() const;
    mfast::decimal_mref set_TotalBuyQuantity() const;
    void omit_TotalBuyQuantity() const;
    mfast::decimal_mref set_TotalSellQuantity() const;
    void omit_TotalSellQuantity() const;

    class MDSshGrp_element_mref
      : public mfast::make_aggregate_mref<DepthSnapshot_cref::MDSshGrp_element_cref>
    {
      typedef mfast::make_aggregate_mref<DepthSnapshot_cref::MDSshGrp_element_cref> base_type;
      public:
        MDSshGrp_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_mref set_MDOriginType() const;
        mfast::uint32_mref set_MDEntryType() const;
        mfast::uint32_mref set_MDBookType() const;
        void omit_MDBookType() const;
        mfast::uint32_mref set_MDSubBookType() const;
        void omit_MDSubBookType() const;
        mfast::uint32_mref set_TrdType() const;
        void omit_TrdType() const;
        mfast::uint32_mref set_TradingSessionID() const;
        void omit_TradingSessionID() const;
        mfast::uint32_mref set_TradingSessionSubID() const;
        void omit_TradingSessionSubID() const;
        mfast::uint32_mref set_TESTradSesStatus() const;
        void omit_TESTradSesStatus() const;
        mfast::uint32_mref set_SecurityTradingStatus() const;
        void omit_SecurityTradingStatus() const;
        mfast::uint32_mref set_MarketCondition() const;
        void omit_MarketCondition() const;
        mfast::uint32_mref set_FastMarketIndicator() const;
        void omit_FastMarketIndicator() const;
        mfast::uint32_mref set_SecurityTradingEvent() const;
        void omit_SecurityTradingEvent() const;
        mfast::uint32_mref set_PotentialSecurityTradingEvent() const;
        void omit_PotentialSecurityTradingEvent() const;
        mfast::uint32_mref set_SoldOutIndicator() const;
        void omit_SoldOutIndicator() const;
        mfast::uint64_mref set_TradeCondition() const;
        void omit_TradeCondition() const;
        mfast::uint32_mref set_MultiLegReportingType() const;
        void omit_MultiLegReportingType() const;
        mfast::uint32_mref set_MultiLegPriceModel() const;
        void omit_MultiLegPriceModel() const;
        mfast::uint32_mref set_QuoteCondition() const;
        void omit_QuoteCondition() const;
        mfast::decimal_mref set_MDEntryPx() const;
        void omit_MDEntryPx() const;
        mfast::decimal_mref set_MDEntrySize() const;
        void omit_MDEntrySize() const;
        mfast::uint32_mref set_NumberOfOrders() const;
        void omit_NumberOfOrders() const;
        mfast::uint32_mref set_MDPriceLevel() const;
        void omit_MDPriceLevel() const;
        mfast::int64_mref set_MDEntryTime() const;
        void omit_MDEntryTime() const;
        mfast::decimal_mref set_NonDisclosedTradeVolume() const;
        void omit_NonDisclosedTradeVolume() const;
        mfast::decimal_mref set_TotalTradedValue() const;
        void omit_TotalTradedValue() const;
        mfast::decimal_mref set_AverageTradedPrice() const;
        void omit_AverageTradedPrice() const;
        mfast::uint32_mref set_TotalNumOfTrades() const;
        void omit_TotalNumOfTrades() const;
    };

    typedef mfast::make_sequence_mref<MDSshGrp_element_mref> MDSshGrp_mref;
    MDSshGrp_mref set_MDSshGrp() const;
};

class DepthSnapshot
  : private mfast::value_storage_array<15>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 101
    };
    typedef mfast::template_instruction_ex<DepthSnapshot_cref> instruction_type;

    typedef mfast::make_message_cref<DepthSnapshot_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<DepthSnapshot_mref, instruction_type> mref_type;
    DepthSnapshot(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    DepthSnapshot(
      const DepthSnapshot_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit DepthSnapshot(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    DepthSnapshot(const DepthSnapshot&);
    DepthSnapshot& operator = (const DepthSnapshot&);
};


class IndexStats_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<IndexStats_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    IndexStats_cref();
    template <typename T>
    IndexStats_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, IndexStats_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    IndexStats_cref(const mfast::message_cref& other);

    explicit IndexStats_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MsgType() const;
    mfast::ascii_string_cref try_get_MsgType() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint32_cref get_SenderCompID() const;
    mfast::uint32_cref try_get_SenderCompID() const;
    mfast::uint32_cref get_MarketSegmentID() const;
    mfast::uint32_cref try_get_MarketSegmentID() const;
    mfast::decimal_cref get_IndexHigh() const;
    mfast::decimal_cref try_get_IndexHigh() const;
    mfast::decimal_cref get_IndexLow() const;
    mfast::decimal_cref try_get_IndexLow() const;
    mfast::decimal_cref get_IndexOpen() const;
    mfast::decimal_cref try_get_IndexOpen() const;
    mfast::decimal_cref get_IndexClose() const;
    mfast::decimal_cref try_get_IndexClose() const;
    mfast::decimal_cref get_IndexValue() const;
    mfast::decimal_cref try_get_IndexValue() const;
    mfast::decimal_cref get_IndexLifeHigh() const;
    mfast::decimal_cref try_get_IndexLifeHigh() const;
    mfast::decimal_cref get_IndexLifeLow() const;
    mfast::decimal_cref try_get_IndexLifeLow() const;
    mfast::decimal_cref get_Index52WeekHigh() const;
    mfast::decimal_cref try_get_Index52WeekHigh() const;
    mfast::decimal_cref get_Index52WeekLow() const;
    mfast::decimal_cref try_get_Index52WeekLow() const;
    mfast::uint32_cref get_CloseIndexFlag() const;
    mfast::uint32_cref try_get_CloseIndexFlag() const;
    mfast::int64_cref get_TransactTime() const;
    mfast::int64_cref try_get_TransactTime() const;

};


typedef mfast::make_aggregate_mref<IndexStats_cref> IndexStats_mref_base;
class IndexStats_mref
  : public IndexStats_mref_base
{
  typedef IndexStats_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<IndexStats_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    IndexStats_mref();
    template <typename T>
    IndexStats_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, IndexStats_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    IndexStats_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit IndexStats_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    void omit_MsgSeqNum() const;
    mfast::uint32_mref set_SenderCompID() const;
    mfast::uint32_mref set_MarketSegmentID() const;
    void omit_MarketSegmentID() const;
    mfast::decimal_mref set_IndexHigh() const;
    void omit_IndexHigh() const;
    mfast::decimal_mref set_IndexLow() const;
    void omit_IndexLow() const;
    mfast::decimal_mref set_IndexOpen() const;
    void omit_IndexOpen() const;
    mfast::decimal_mref set_IndexClose() const;
    void omit_IndexClose() const;
    mfast::decimal_mref set_IndexValue() const;
    void omit_IndexValue() const;
    mfast::decimal_mref set_IndexLifeHigh() const;
    void omit_IndexLifeHigh() const;
    mfast::decimal_mref set_IndexLifeLow() const;
    void omit_IndexLifeLow() const;
    mfast::decimal_mref set_Index52WeekHigh() const;
    void omit_Index52WeekHigh() const;
    mfast::decimal_mref set_Index52WeekLow() const;
    void omit_Index52WeekLow() const;
    mfast::uint32_mref set_CloseIndexFlag() const;
    void omit_CloseIndexFlag() const;
    mfast::int64_mref set_TransactTime() const;
};

class IndexStats
  : private mfast::value_storage_array<15>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 51
    };
    typedef mfast::template_instruction_ex<IndexStats_cref> instruction_type;

    typedef mfast::make_message_cref<IndexStats_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<IndexStats_mref, instruction_type> mref_type;
    IndexStats(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    IndexStats(
      const IndexStats_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit IndexStats(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    IndexStats(const IndexStats&);
    IndexStats& operator = (const IndexStats&);
};


class TopOfBookImplied_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<TopOfBookImplied_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    TopOfBookImplied_cref();
    template <typename T>
    TopOfBookImplied_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, TopOfBookImplied_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    TopOfBookImplied_cref(const mfast::message_cref& other);

    explicit TopOfBookImplied_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MsgType() const;
    mfast::ascii_string_cref try_get_MsgType() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint32_cref get_SenderCompID() const;
    mfast::uint32_cref try_get_SenderCompID() const;
    mfast::uint32_cref get_MarketSegmentID() const;
    mfast::uint32_cref try_get_MarketSegmentID() const;

    class MDIncGrp_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<MDIncGrp_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        MDIncGrp_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_cref get_MDUpdateAction() const;
        mfast::uint32_cref try_get_MDUpdateAction() const;
        mfast::uint32_cref get_MDEntryType() const;
        mfast::uint32_cref try_get_MDEntryType() const;
        mfast::uint32_cref get_MDBookType() const;
        mfast::uint32_cref try_get_MDBookType() const;
        mfast::uint32_cref get_MDSubBookType() const;
        mfast::uint32_cref try_get_MDSubBookType() const;
        mfast::int64_cref get_SecurityID() const;
        mfast::int64_cref try_get_SecurityID() const;
        mfast::ascii_string_cref get_SecurityIDSource() const;
        mfast::ascii_string_cref try_get_SecurityIDSource() const;
        mfast::decimal_cref get_MDEntryPx() const;
        mfast::decimal_cref try_get_MDEntryPx() const;
        mfast::decimal_cref get_MDEntrySize() const;
        mfast::decimal_cref try_get_MDEntrySize() const;
        mfast::int64_cref get_MDEntryTime() const;
        mfast::int64_cref try_get_MDEntryTime() const;
        mfast::uint32_cref get_QuoteCondition() const;
        mfast::uint32_cref try_get_QuoteCondition() const;
    };

    typedef mfast::make_sequence_cref<MDIncGrp_element_cref> MDIncGrp_cref;
    MDIncGrp_cref get_MDIncGrp() const;
    MDIncGrp_cref try_get_MDIncGrp() const;

};


typedef mfast::make_aggregate_mref<TopOfBookImplied_cref> TopOfBookImplied_mref_base;
class TopOfBookImplied_mref
  : public TopOfBookImplied_mref_base
{
  typedef TopOfBookImplied_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<TopOfBookImplied_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    TopOfBookImplied_mref();
    template <typename T>
    TopOfBookImplied_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, TopOfBookImplied_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    TopOfBookImplied_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit TopOfBookImplied_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    mfast::uint32_mref set_SenderCompID() const;
    mfast::uint32_mref set_MarketSegmentID() const;

    class MDIncGrp_element_mref
      : public mfast::make_aggregate_mref<TopOfBookImplied_cref::MDIncGrp_element_cref>
    {
      typedef mfast::make_aggregate_mref<TopOfBookImplied_cref::MDIncGrp_element_cref> base_type;
      public:
        MDIncGrp_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_mref set_MDUpdateAction() const;
        mfast::uint32_mref set_MDEntryType() const;
        mfast::uint32_mref set_MDSubBookType() const;
        mfast::int64_mref set_SecurityID() const;
        mfast::decimal_mref set_MDEntryPx() const;
        void omit_MDEntryPx() const;
        mfast::decimal_mref set_MDEntrySize() const;
        void omit_MDEntrySize() const;
        mfast::int64_mref set_MDEntryTime() const;
        void omit_MDEntryTime() const;
        mfast::uint32_mref set_QuoteCondition() const;
        void omit_QuoteCondition() const;
    };

    typedef mfast::make_sequence_mref<MDIncGrp_element_mref> MDIncGrp_mref;
    MDIncGrp_mref set_MDIncGrp() const;
};

class TopOfBookImplied
  : private mfast::value_storage_array<5>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 513
    };
    typedef mfast::template_instruction_ex<TopOfBookImplied_cref> instruction_type;

    typedef mfast::make_message_cref<TopOfBookImplied_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<TopOfBookImplied_mref, instruction_type> mref_type;
    TopOfBookImplied(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    TopOfBookImplied(
      const TopOfBookImplied_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit TopOfBookImplied(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    TopOfBookImplied(const TopOfBookImplied&);
    TopOfBookImplied& operator = (const TopOfBookImplied&);
};


class FlexibleInstrumentUpdate_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<FlexibleInstrumentUpdate_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    FlexibleInstrumentUpdate_cref();
    template <typename T>
    FlexibleInstrumentUpdate_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, FlexibleInstrumentUpdate_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    FlexibleInstrumentUpdate_cref(const mfast::message_cref& other);

    explicit FlexibleInstrumentUpdate_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MsgType() const;
    mfast::ascii_string_cref try_get_MsgType() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint32_cref get_SenderCompID() const;
    mfast::uint32_cref try_get_SenderCompID() const;
    mfast::ascii_string_cref get_SecurityUpdateAction() const;
    mfast::ascii_string_cref try_get_SecurityUpdateAction() const;
    mfast::int64_cref get_SecurityID() const;
    mfast::int64_cref try_get_SecurityID() const;
    mfast::ascii_string_cref get_SecurityIDSource() const;
    mfast::ascii_string_cref try_get_SecurityIDSource() const;
    mfast::ascii_string_cref get_SecurityDesc() const;
    mfast::ascii_string_cref try_get_SecurityDesc() const;
    mfast::uint32_cref get_SecurityType() const;
    mfast::uint32_cref try_get_SecurityType() const;
    mfast::uint32_cref get_ProductComplex() const;
    mfast::uint32_cref try_get_ProductComplex() const;
    mfast::uint32_cref get_MaturityDate() const;
    mfast::uint32_cref try_get_MaturityDate() const;
    mfast::decimal_cref get_StrikePrice() const;
    mfast::decimal_cref try_get_StrikePrice() const;
    mfast::uint32_cref get_PutOrCall() const;
    mfast::uint32_cref try_get_PutOrCall() const;
    mfast::uint32_cref get_OptAttribute() const;
    mfast::uint32_cref try_get_OptAttribute() const;
    mfast::uint32_cref get_ExerciseStyle() const;
    mfast::uint32_cref try_get_ExerciseStyle() const;
    mfast::uint32_cref get_SettlMethod() const;
    mfast::uint32_cref try_get_SettlMethod() const;

    class MarketSegmentGrp_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<MarketSegmentGrp_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        MarketSegmentGrp_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_cref get_MarketSegmentID() const;
        mfast::uint32_cref try_get_MarketSegmentID() const;
    };

    typedef mfast::make_sequence_cref<MarketSegmentGrp_element_cref> MarketSegmentGrp_cref;
    MarketSegmentGrp_cref get_MarketSegmentGrp() const;
    MarketSegmentGrp_cref try_get_MarketSegmentGrp() const;
    mfast::int64_cref get_TransactTime() const;
    mfast::int64_cref try_get_TransactTime() const;

};


typedef mfast::make_aggregate_mref<FlexibleInstrumentUpdate_cref> FlexibleInstrumentUpdate_mref_base;
class FlexibleInstrumentUpdate_mref
  : public FlexibleInstrumentUpdate_mref_base
{
  typedef FlexibleInstrumentUpdate_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<FlexibleInstrumentUpdate_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    FlexibleInstrumentUpdate_mref();
    template <typename T>
    FlexibleInstrumentUpdate_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, FlexibleInstrumentUpdate_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    FlexibleInstrumentUpdate_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit FlexibleInstrumentUpdate_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    mfast::uint32_mref set_SenderCompID() const;
    mfast::int64_mref set_SecurityID() const;
    mfast::ascii_string_mref set_SecurityDesc() const;
    mfast::uint32_mref set_SecurityType() const;
    mfast::uint32_mref set_ProductComplex() const;
    mfast::uint32_mref set_MaturityDate() const;
    mfast::decimal_mref set_StrikePrice() const;
    void omit_StrikePrice() const;
    mfast::uint32_mref set_PutOrCall() const;
    void omit_PutOrCall() const;
    mfast::uint32_mref set_OptAttribute() const;
    void omit_OptAttribute() const;
    mfast::uint32_mref set_ExerciseStyle() const;
    void omit_ExerciseStyle() const;
    mfast::uint32_mref set_SettlMethod() const;

    class MarketSegmentGrp_element_mref
      : public mfast::make_aggregate_mref<FlexibleInstrumentUpdate_cref::MarketSegmentGrp_element_cref>
    {
      typedef mfast::make_aggregate_mref<FlexibleInstrumentUpdate_cref::MarketSegmentGrp_element_cref> base_type;
      public:
        MarketSegmentGrp_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_mref set_MarketSegmentID() const;
    };

    typedef mfast::make_sequence_mref<MarketSegmentGrp_element_mref> MarketSegmentGrp_mref;
    MarketSegmentGrp_mref set_MarketSegmentGrp() const;
    mfast::int64_mref set_TransactTime() const;
};

class FlexibleInstrumentUpdate
  : private mfast::value_storage_array<17>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 110
    };
    typedef mfast::template_instruction_ex<FlexibleInstrumentUpdate_cref> instruction_type;

    typedef mfast::make_message_cref<FlexibleInstrumentUpdate_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<FlexibleInstrumentUpdate_mref, instruction_type> mref_type;
    FlexibleInstrumentUpdate(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    FlexibleInstrumentUpdate(
      const FlexibleInstrumentUpdate_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit FlexibleInstrumentUpdate(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    FlexibleInstrumentUpdate(const FlexibleInstrumentUpdate&);
    FlexibleInstrumentUpdate& operator = (const FlexibleInstrumentUpdate&);
};


class Reset_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<Reset_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Reset_cref();
    template <typename T>
    Reset_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, Reset_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    Reset_cref(const mfast::message_cref& other);

    explicit Reset_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);


};


typedef mfast::make_aggregate_mref<Reset_cref> Reset_mref_base;
class Reset_mref
  : public Reset_mref_base
{
  typedef Reset_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<Reset_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Reset_mref();
    template <typename T>
    Reset_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, Reset_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    Reset_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit Reset_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

};

class Reset
  : private mfast::value_storage_array<0>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 120
    };
    typedef mfast::template_instruction_ex<Reset_cref> instruction_type;

    typedef mfast::make_message_cref<Reset_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<Reset_mref, instruction_type> mref_type;
    Reset(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    Reset(
      const Reset_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit Reset(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    Reset(const Reset&);
    Reset& operator = (const Reset&);
};


struct  templates_description
  : mfast::templates_description
{
  typedef std::tuple<MDPacketHeader,
                       ProductStateChange,
                       MassInstrumentStateChange,
                       InstrumentStateChange,
                       DepthIncremental,
                       ComplexInstrumentUpdate,
                       QuoteRequest,
                       CrossRequest,
                       DepthSnapshot,
                       IndexStats,
                       TopOfBookImplied,
                       FlexibleInstrumentUpdate,
                       Reset> types;
  templates_description();
  static const templates_description* instance();
};

inline const templates_description* description()
{
  return templates_description::instance();
}

#include "MDIFastTemplates_1_1.inl"
}
